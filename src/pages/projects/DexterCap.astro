---
import PageLayout from '@/layouts/CommonPage.astro'
import { Image } from 'astro:assets'

import { Comment } from '@/components/advanced'
import { Button } from '@/components/user'
import dexterCap1 from '@/assets/projects/DexterCap/DexterCap-1.png'
import dexterCap2 from '@/assets/projects/DexterCap/DexterCap-2.png'
import dexterCap3 from '@/assets/projects/DexterCap/DexterCap-3.png'
import dexterCap4 from '@/assets/projects/DexterCap/DexterCap-4.png'
import dexterCapImage from '@/assets/projects/DexterCap/DexterCap-full.png'

// Assuming images are in public/images/projects/ or similar path.
// If using Astro's <Image> component, import it:
// import { Image } from 'astro:assets';
// And import the image if it's in src/assets:
// import dexterCapImage from '@/assets/projects/DexterCap.png';

export const prerender = true

const preload = true

const pageTitle =
  'DexterCap: An Affordable and Automated System for Capturing Dexterous Hand-Object Manipulation'

const actionButtonClass = 'rerun-load-button rounded-xl px-4 py-2 text-base'
const toolbarButtonClass = 'copy-button rounded-xl px-3 py-1.5 text-sm'

// PLACEHOLDER: Please update with actual authors and affiliations
const authors = [
  { name: 'Yutong Liang', sup: '*‡1, 2', url: 'https://www.lyt0112.com' },
  { name: 'Shiyi Xu', sup: '*1', url: '#' },
  { name: 'Yulong Zhang', sup: '*1', url: '#' },
  { name: 'Bowen Zhan', sup: '1', url: '#' },
  { name: 'He Zhang', sup: '3', url: 'https://cghezhang.github.io' },
  { name: 'Libin Liu', sup: '†1', url: 'https://libliu.info' }
]
const rawAffiliationsString = '1. Peking University, 2. UCSD, 3. Tencent'
const affiliationItems = rawAffiliationsString.split(/\s*,\s*/).map((item) => {
  const match = item.match(/^(\d+)\.\s*(.*)$/)
  if (match) {
    return { number: match[1], name: match[2] }
  }
  return { name: item } // Fallback if no number, though not expected with current string
})

// Updated author notes
const authorNotes = ['* Equal contribution.', '† Corresponding author.', '‡ Work done at Peking University.']

// PLACEHOLDER: Please update with actual links
const paperLink = '#'
const publicDataLink = 'https://huggingface.co/datasets/pku-mocca/DexterHand/tree/main'
const githubLink = 'https://github.com/PKU-MoCCA/hand-mocap'

// Assumed image path. If your image 'DexterCap.png' is elsewhere (e.g. src/assets),
// this path or the image handling method needs adjustment.
// const imageUrl = 'DexterCap.png'

// Overview text extracted from comments in projects/index.astro
const abstractContent = `Modeling complex, fine-grained hand-object interactions remains challenging, in
part due to the limited availability of dedicated datasets and specialized capture methods.
Existing motion capture systems are generally limited to basic motion types, such as grasping,
and interactions with primitive rigid or articulated objects. To facilitate the exploration of
intricate, dexterous in-hand manipulations with more complex objects, we present DexterCap. We
first design a robust, low-cost, and high-fidelity motion capture hardware system that acquires
reliable data even in the presence of self-occlusion and complex manipulation. To ensure
accurate capture despite severe occlusions, we introduce a specialized patch maker equipped with
an effective detection and optimization pipeline. We further develop an automated data
augmentation pipeline to reconstruct and refine motion data with minimal manual effort,
improving both efficiency and data quality. Using this system, we create the DexterHand dataset,
which includes subtle, fine-grained manipulation behaviors and interactions with multi-jointed
objects such as a Rubik's cube. By releasing the dataset and supporting source code to the
community, we hope that DexterCap will facilitate further research on intricate hand-object
interactions.`

// Headings for the right sidebar navigation
const headings = [
  // { depth: 2, slug: 'abstract', text: 'Abstract' },
  { depth: 2, slug: 'rrd-viewer', text: 'Interactive Visualization' },
  { depth: 2, slug: 'dataset', text: 'Dataset' },
  { depth: 2, slug: 'system-pipeline', text: 'System Pipeline' },
  { depth: 2, slug: 'bibtex', text: 'BibTeX' } // Example, add more if needed
]

const citationText = `@misc{liang2025dextercap,
  author       = {Yutong Liang, Shiyi Xu, Yulong Zhang, Bowen Zhan, He Zhang and Libin Liu},
  title        = {DexterCap: An Affordable and Automated System for Capturing Dexterous Hand-Object Manipulation},
  year         = {2025},
  publisher    = {arXiv},
  version      = {arXiv:#},
  doi          = {#},
  url          = {https://www.lyt0112.com/projects/DexterCap/}
}`
---

<PageLayout
  title={pageTitle}
  headings={headings}
  info={{ slug: '/projects/DexterCap', hideComment: false }}
  hideBack={true}
>
  <style>
    @media (min-width: 1024px) {
      :global(main):has(.dextercap-page) > :global(div.mx-auto.w-full) {
        max-width: 80vw !important;
      }
      :global(main):has(.dextercap-page) :global(#content) {
        max-width: none !important;
        width: 100%;
      }
    }

    .project-container {
      padding: 1rem;
    }
    .project-header h1 {
      font-size: 2.25rem; /* Adjusted for consistency, increased from 2rem */
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 0.75rem;
    }
    .authors {
      font-size: 1.35rem; /* Slightly larger as requested: "作者名字可以稍微变大" */
      color: var(--text-color-primary); /* Using theme variables if available */
      margin-bottom: 0.5rem; /* Spacing below authors block */
      text-align: center; /* Center align authors */
      display: flex; /* Added for gap spacing */
      flex-wrap: wrap; /* Allow wrapping */
      justify-content: center; /* Center items in the flex container */
      gap: 1.5em; /* Increased spacing between author items: "距离可以再大一些" */
    }
    .authors a {
      text-decoration: none;
    }
    .authors a.actual-author-link {
      color: royalblue; /* Deeper blue for actual links - "湖蓝色" */
    }
    .authors a.actual-author-link:hover {
      text-decoration: underline;
    }
    .authors a.placeholder-author-link {
      color: inherit; /* Inherit from .authors, which uses var(--text-color-primary) */
      cursor: default;
    }
    .authors a.placeholder-author-link:hover {
      text-decoration: none; /* No underline for placeholder links on hover */
    }
    .authors a:hover {
      /* text-decoration: underline; */ /* This was general, moved to actual-author-link:hover */
    }
    .affiliations {
      font-size: 1rem; /* Slightly larger for better visibility, image has clear affiliations */
      color: var(--text-color-secondary); /* Using theme variables if available */
      margin-bottom: 1rem; /* Consolidate margin, spacing below affiliations */
      text-align: center; /* Center align affiliations */
      display: flex; /* Added for gap spacing */
      flex-wrap: wrap; /* Allow wrapping */
      justify-content: center; /* Center items */
      gap: 1.2em; /* Spacing between affiliation items, "都不用逗号分隔" implies visual separation */
    }
    .author-notes {
      font-size: 0.8rem; /* Adjusted */
      color: var(--text-color-tertiary); /* Using theme variables if available */
      margin-bottom: 1.5rem;
      list-style-type: none;
      padding-left: 0;
      text-align: center; /* Center align author notes */
      white-space: nowrap;
    }
    .author-notes p {
      margin: 0;
    }
    .project-links {
      margin-bottom: 2rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center; /* Center align buttons */
    }
    .project-links a {
      text-decoration: none;
    }
    .project-media {
      margin-top: 2rem;
      margin-bottom: 2rem;
      text-align: center;
    }
    .project-media img,
    .project-media video {
      max-width: 100%;
      height: auto;
      border-radius: 0.5rem; /* Tailwind lg */
      box-shadow: var(
        --shadow-md,
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06)
      );
    }
    .project-section h2 {
      font-size: 1.5rem; /* Adjusted */
      font-weight: 600;
      margin-top: 2.5rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid var(--border-color, #eee);
      padding-bottom: 0.5rem;
    }
    .project-section p,
    .project-section pre {
      font-size: 1rem;
      line-height: 1.7; /* Increased for readability */
      margin-bottom: 1rem;
    }
    .project-section pre {
      background-color: var(--color-gray-100, #f4f4f4);
      padding: 1rem;
      border-radius: 0.375rem;
      overflow-x: auto;
      font-family: var(--font-mono, monospace);
      position: relative; /* For positioning the copy button */
      color: var(--code-text-color, var(--text-color)); /* Adapts to dark/light mode */
    }

    .bibtex-card {
      border: 1px solid hsl(var(--border));
      border-radius: 0.75rem;
      overflow: hidden;
      background: hsl(var(--card));
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
    }
    .bibtex-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      background: hsl(var(--muted));
      border-bottom: 1px solid hsl(var(--border));
      gap: 0.75rem;
    }
    .bibtex-toolbar-title {
      font-family: var(
        --font-mono,
        ui-monospace,
        SFMono-Regular,
        Menlo,
        Monaco,
        Consolas,
        monospace
      );
      font-size: 0.72rem;
      color: hsl(var(--muted-foreground));
      letter-spacing: 0.02em;
      user-select: none;
    }
    .bibtex-card pre {
      margin: 0;
      border-radius: 0;
      background: hsl(var(--background));
      padding: 0.85rem 1rem;
      position: static;
      color: hsl(var(--foreground));
      font-size: 0.78rem;
      line-height: 1.55;
      tab-size: 2;
    }
    .bibtex-card code {
      display: block;
      color: hsl(var(--foreground));
    }

    /* Dark mode specific adjustments for pre and copy button if needed */
    :global(html.dark) .project-section pre {
      background-color: var(--color-gray-800, #1f2937); /* Darker for pre background */
      color: var(--color-gray-200, #e5e7eb); /* Lighter text for pre */
    }
    :global(html.dark) .bibtex-card pre {
      background: hsl(var(--background));
      color: hsl(var(--foreground));
    }

    /* === START REPLACEMENT FOR VIDEO GALLERY STYLES === */
    .video-gallery {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .main-video-container {
      width: 100%;
      text-align: center;
    }
    @media (min-width: 768px) {
      .main-video-container {
        width: 30%;
      }
    }
    #gallery-main-video {
      box-shadow: var(
        --shadow-md,
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06)
      );
      width: 100%;
      height: auto;
      border-radius: 0.5rem;
    }
    /* === END REPLACEMENT FOR VIDEO GALLERY STYLES === */

    /* === START RERUN (RRD) VIEWER STYLES === */
    .rerun-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
      margin: 1rem 0 1rem 0;
    }
    .rerun-load-button.is-active {
      background: hsl(var(--primary));
      color: hsl(var(--primary-foreground));
      border-color: hsl(var(--primary));
    }
    .rerun-load-button.is-active:hover {
      background: hsl(var(--primary));
      color: hsl(var(--primary-foreground));
      border-color: hsl(var(--primary));
    }
    .rerun-status {
      text-align: center;
      font-size: 0.95rem;
      color: hsl(var(--muted-foreground));
      margin-bottom: 0.75rem;
    }
    .rerun-progress-container {
      display: none;
      justify-content: center;
      margin-bottom: 0.75rem;
    }
    .rerun-progress-container.is-visible {
      display: flex;
    }
    .rerun-progress {
      width: min(560px, 100%);
      height: 10px;
    }
    .rerun-viewer {
      display: none;
      width: 100%;
      height: 720px;
      border: 1px solid hsl(var(--border));
      border-radius: 0.75rem;
      overflow: hidden;
      background: hsl(var(--background));
    }
    .rerun-viewer.is-visible {
      display: block;
    }
    /* === END RERUN (RRD) VIEWER STYLES === */

    .pipeline-images-container {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      justify-content: space-around; /* Distribute space */
      gap: 0.5rem; /* Space between images */
      margin-bottom: 1rem;
    }
    .pipeline-image-wrapper {
      flex: 1 1 calc(50% - 0.25rem); /* Aim for 2 per row, accounting for 0.5rem container gap */
      min-width: 240px; /* Adjust min-width for a 2-column layout */
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .pipeline-image-wrapper img {
      width: 50%;
      height: auto;
      border-radius: 0.375rem; /* Tailwind md */
      box-shadow: var(--shadow-sm, 0 1px 2px 0 rgba(0, 0, 0, 0.05));
    }
    .pipeline-caption {
      font-size: 0.9rem;
      color: var(--text-color-secondary);
      text-align: center;
      margin-top: 0.5rem;
      font-style: italic;
    }
    .individual-image-caption {
      font-size: 0.85rem; /* Adjusted for clarity */
      color: var(--text-color-secondary);
      text-align: center;
      margin-top: 0.3rem; /* Reduced margin */
      padding: 0 0.25rem; /* Add a little horizontal padding */
    }

    .pipeline-videos-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      gap: 0.5rem; /* Consistent with images */
      margin-top: 1.5rem; /* Space below image grid */
      margin-bottom: 1rem;
    }
    .pipeline-video-wrapper {
      flex: 1 1 calc(50% - 0.25rem); /* Two videos per row */
      min-width: 280px; /* Min width for videos */
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .pipeline-video-wrapper video {
      width: 50%;
      height: auto;
      border-radius: 0.375rem; /* Tailwind md */
      box-shadow: var(--shadow-sm, 0 1px 2px 0 rgba(0, 0, 0, 0.05));
    }
  </style>

  <div class='project-container dextercap-page'>
    <div class='authors'>
      {
        authors.map((author) => {
          const isPlaceholder = author.url === '#'
          return (
            <span class='author-item'>
              <a
                href={author.url}
                target={isPlaceholder ? undefined : '_blank'}
                rel={isPlaceholder ? undefined : 'noopener noreferrer'}
                class={isPlaceholder ? 'placeholder-author-link' : 'actual-author-link'}
              >
                {author.name}
              </a>
              <sup>{author.sup}</sup>
            </span>
          )
        })
      }
    </div>
    <div class='affiliations'>
      {
        affiliationItems.map((item) => (
          <span class='affiliation-item'>
            {item.number && <sup>{item.number}</sup>} {item.name}
          </span>
        ))
      }
    </div>
    <div class='author-notes'>
      <p>{authorNotes.join(' ')}</p>
    </div>

    <nav class='project-links'>
      <Button
        class={actionButtonClass}
        href={paperLink}
        target='_blank'
        rel='noopener noreferrer'
        title='Paper'
      />
      <Button
        class={actionButtonClass}
        href={githubLink}
        target='_blank'
        rel='noopener noreferrer'
        title='Code'
      />
      <Button
        class={actionButtonClass}
        href={publicDataLink}
        target='_blank'
        rel='noopener noreferrer'
        title='Dataset'
      />
    </nav>

    <section class='project-media'>
      <Image src={dexterCapImage} alt='DexterCap Project Visualization' />
      <!-- If you have a video, you could use:
      <video controls src="/path/to/your/video.mp4" style="max-width: 100%; border-radius: 0.5rem;"></video>
      Or an iframe for YouTube/Vimeo:
      <iframe width="560" height="315" src="https://www.youtube.com/embed/YOUR_VIDEO_ID" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="max-width: 100%; border-radius: 0.5rem;"></iframe>
      -->
    </section>

    <p
      style='font-size: 1.5rem; font-weight: bold; line-height: 1.7; margin-top: 2rem; margin-bottom: 1.5rem; text-align: center;'
    >
      DexterCap captures dexterous in-hand manipulations by providing dense motion information and reducing marker interference.
    </p>

    <!-- <article class='project-section'>
      <h2 id='abstract'>Abstract</h2>
      <p>{abstractContent}</p>
    </article> -->

    <section class='project-section'>
      <h2 id='rrd-viewer'>Interactive Visualization</h2>
      <div class='rerun-controls' id='rerun-controls'>
        <Button
          as='button'
          class={actionButtonClass}
          data-rrd-key='rubikscube'
          data-rrd-title="Rubik's Cube"
          data-rrd-url='https://cdn.lyt0112.com/Projects/DexterCap/RubiksCube-363-391.rrd'
          type='button'
          title="Rubik's Cube"
        />
        <Button
          as='button'
          class={actionButtonClass}
          data-rrd-key='cuboid0'
          data-rrd-title='Cuboid 0'
          data-rrd-url='https://cdn.lyt0112.com/Projects/DexterCap/Cuboid_00-301-306.rrd'
          type='button'
          title='Cuboid 0'
        />
        <Button
          as='button'
          class={actionButtonClass}
          data-rrd-key='cuboid1'
          data-rrd-title='Cuboid 1'
          data-rrd-url='https://cdn.lyt0112.com/Projects/DexterCap/Cuboid_01-551-556.rrd'
          type='button'
          title='Cuboid 1'
        />
        <Button
          as='button'
          class={actionButtonClass}
          data-rrd-key='cuboid2'
          data-rrd-title='Cuboid 2'
          data-rrd-url='https://cdn.lyt0112.com/Projects/DexterCap/Cuboid_02-204-209.rrd'
          type='button'
          title='Cuboid 2'
        />
      </div>
      <p class='rerun-status' id='rerun-status'>Click a button to load a recording.</p>
      <div class='rerun-progress-container' id='rerun-progress-container'>
        <progress class='rerun-progress' id='rerun-progress'></progress>
      </div>
      <!-- <p>
        If switching the sequence fails, toggle the left (blueprint) panel and switch the sequence
        manually.
        </p>
      <p>
        If loading fails, clean browser cache and try again.
        </p> -->
      <div class='rerun-viewer' id='rerun-root'></div>
    </section>

    <section class='project-section'>
      <h2 id='dataset'>Gallery</h2>
      <div class='video-gallery'>
        <div class='rerun-controls' id='gallery-controls'>
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='0'
            type='button'
            title="Rubik's Cube"
          />
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='1'
            type='button'
            title='Cylinder'
          />
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='2'
            type='button'
            title='Plate'
          />
          <Button as='button' class={actionButtonClass} data-gallery-index='3' type='button' title='Prism' />
          <Button as='button' class={actionButtonClass} data-gallery-index='4' type='button' title='Ring' />
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='5'
            type='button'
            title='Cuboid 0'
          />
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='6'
            type='button'
            title='Cuboid 1'
          />
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='7'
            type='button'
            title='Cuboid 2 (1)'
          />
          <Button
            as='button'
            class={actionButtonClass}
            data-gallery-index='8'
            type='button'
            title='Cuboid 2 (2)'
          />
        </div>
        <div class='main-video-container'>
          <video
            id='gallery-main-video'
            controls
            loop
            muted
            playsinline
            autoplay={preload}
            preload={preload ? 'auto' : 'metadata'}
          >
            {/* Source will be set by JS */}
          </video>
          <figcaption
            id='gallery-main-caption'
            style='text-align: center; font-size: 1.1rem; margin-top: 0.75rem;'
          >
            {/* Caption will be set by JS */}
          </figcaption>
        </div>
      </div>
    </section>

    <section class='project-section'>
      <h2 id='system-pipeline'>System Pipeline</h2>
      <p style='margin-bottom: 0.75rem; text-align: left;'>
        1. 3D marker detection from multi-view images:
      </p>
      <div class='pipeline-images-container'>
        <div class='pipeline-image-wrapper'>
          <Image src={dexterCap1} alt='Raw input image with markers' />
          <p class='individual-image-caption'>
            a. Raw input image with character-coded checkerboard markers.
          </p>
        </div>
        <div class='pipeline-image-wrapper'>
          <Image src={dexterCap2} alt='CornerNet detection results' />
          <p class='individual-image-caption'>b. CornerNet detection results.</p>
        </div>
        <div class='pipeline-image-wrapper'>
          <Image src={dexterCap3} alt='EdgeNet edge classification results' />
          <p class='individual-image-caption'>c. EdgeNet edge classification results.</p>
        </div>
        <div class='pipeline-image-wrapper'>
          <Image src={dexterCap4} alt='BlockNet block recognition' />
          <p class='individual-image-caption'>
            d. BlockNet block recognition with character identifiers.
          </p>
        </div>
      </div>
      <p style='margin-bottom: 0.75rem; text-align: left;'>
        2. Hand and object reconstruction from 3D marker positions:
      </p>
      <div class='pipeline-videos-container'>
        <div class='pipeline-video-wrapper'>
          <video
            controls
            loop
            autoplay={preload}
            preload={preload ? 'auto' : 'metadata'}
            src='https://cdn.lyt0112.com/Projects/DexterCap/hand-reconstruction.mp4'
          >
            Your browser does not support the video tag.
          </video>
          <p class='individual-image-caption'>Hand Reconstruction</p>
        </div>
        <div class='pipeline-video-wrapper'>
          <video
            controls
            loop
            autoplay={preload}
            preload={preload ? 'auto' : 'metadata'}
            src='https://cdn.lyt0112.com/Projects/DexterCap/rubikscube_reconstruction.mp4'
          >
            Your browser does not support the video tag.
          </video>
          <p class='individual-image-caption'>Object Reconstruction</p>
        </div>
      </div>
    </section>

    <section class='project-section'>
      <h2 id='bibtex'>BibTeX</h2>
      <p>If you find DexterCap useful in your research, please consider citing:</p>
      <div class='bibtex-card'>
        <div class='bibtex-toolbar'>
          <span class='bibtex-toolbar-title'>citation.bib</span>
          <Button
            as='button'
            class={actionButtonClass}
            id='copy-citation-button'
            type='button'
            title='Copy'
          />
        </div>
        <pre><code id='citation-code'>{citationText}</code></pre>
      </div>
    </section>
  </div>

  <Comment />
</PageLayout>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // --- Existing Copy Citation Logic ---
    /**
     * Copies the BibTeX citation text to the clipboard and updates the UI button state.
     *
     * @returns {void} (Type: void, Shape: N/A)
     */
    function copyCitation() {
      const citationCode = document.getElementById('citation-code') as HTMLElement
      if (citationCode) {
        navigator.clipboard
          .writeText(citationCode.innerText)
          .then(() => {
            const button = document.getElementById('copy-citation-button') as HTMLButtonElement
            if (button) {
              button.innerText = 'Copied!'
              setTimeout(() => {
                button.innerText = 'Copy'
              }, 2000)
            }
          })
          .catch((err) => {
            console.error('Failed to copy citation: ', err)
          })
      }
    }

    const copyButton = document.getElementById('copy-citation-button')
    if (copyButton) {
      copyButton.addEventListener('click', copyCitation)
    }

    // --- START RERUN (RRD) VIEWER LOGIC ---
    const rerunButtons = Array.from(
      document.querySelectorAll<HTMLButtonElement>('#rerun-controls .rerun-load-button')
    )
    const rerunRootElement = document.getElementById('rerun-root') as HTMLElement | null
    const rerunStatusElement = document.getElementById('rerun-status') as HTMLElement | null
    const rerunProgressContainerElement = document.getElementById(
      'rerun-progress-container'
    ) as HTMLElement | null
    const rerunProgressElement = document.getElementById(
      'rerun-progress'
    ) as HTMLProgressElement | null

    let rerunViewer: import('@rerun-io/web-viewer').WebViewer | null = null
    let rerunViewerStartPromise: Promise<void> | null = null
    let rerunChannel: import('@rerun-io/web-viewer').LogChannel | null = null
    let rerunDownloadAbortController: AbortController | null = null
    let lastRerunProgressPercent: number | null = null
    let lastRerunProgressHalfMiBStep: number | null = null
    const RRD_TOTAL_BYTES_BY_KEY: Record<string, number> = {
      /**
       * These values are used only when `Content-Length` is missing (common on some serverless platforms).
       * They are approximate sizes in MiB, converted to bytes for percent-based progress UI.
       */
      rubikscube: Math.round(13.38 * 1024 * 1024),
      cuboid0: Math.round(5.8 * 1024 * 1024),
      cuboid1: Math.round(5.79 * 1024 * 1024),
      cuboid2: Math.round(5.8 * 1024 * 1024)
    }

    /**
     * Updates the status text shown above the viewer.
     *
     * @param {string} statusText - Human-readable status message. (Type: string, Shape: scalar)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function setRerunStatus(statusText: string): void {
      if (!rerunStatusElement) return
      rerunStatusElement.textContent = statusText
    }

    /**
     * Shows or hides the download progress bar.
     *
     * @param {boolean} isVisible - Whether the progress bar should be visible. (Type: boolean, Shape: scalar)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function setRerunProgressVisible(isVisible: boolean): void {
      if (!rerunProgressContainerElement) return
      rerunProgressContainerElement.classList.toggle('is-visible', isVisible)
    }

    /**
     * Sets the progress bar to indeterminate mode.
     *
     * @returns {void} (Type: void, Shape: N/A)
     */
    function setRerunProgressIndeterminate(): void {
      if (!rerunProgressElement) return
      rerunProgressElement.removeAttribute('value')
      rerunProgressElement.max = 1
    }

    /**
     * Updates the progress bar based on downloaded bytes and optionally updates the status text.
     *
     * @param {number} loadedBytes - Downloaded bytes so far. (Type: number, Shape: scalar)
     * @param {number} totalBytes - Total bytes from `Content-Length` header (0 if unknown). (Type: number, Shape: scalar)
     * @param {string} rrdTitle - Display title for the current recording. (Type: string, Shape: scalar)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function updateRerunProgress(loadedBytes: number, totalBytes: number, rrdTitle: string): void {
      if (!rerunProgressElement) return

      if (totalBytes > 0) {
        rerunProgressElement.max = totalBytes
        const clampedLoadedBytes = Math.min(loadedBytes, totalBytes)
        rerunProgressElement.value = clampedLoadedBytes

        const percent = Math.min(100, Math.floor((clampedLoadedBytes / totalBytes) * 100))
        if (percent !== lastRerunProgressPercent) {
          lastRerunProgressPercent = percent
          setRerunStatus(`Loading: ${rrdTitle}... (${percent}%)`)
        }
      } else {
        const halfMiB = 512 * 1024
        const halfMiBStep = Math.floor(loadedBytes / halfMiB)
        if (halfMiBStep !== lastRerunProgressHalfMiBStep) {
          lastRerunProgressHalfMiBStep = halfMiBStep
          const loadedMiB = (halfMiBStep * 0.5).toFixed(1)
          setRerunStatus(`Loading: ${rrdTitle}... (${loadedMiB} MiB)`)
        }
      }
    }

    /**
     * Updates button styles to reflect which recording is currently selected.
     *
     * @param {HTMLButtonElement} activeButton - The button to mark as active. (Type: HTMLButtonElement, Shape: scalar DOM node)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function setActiveRerunButton(activeButton: HTMLButtonElement): void {
      for (const button of rerunButtons) {
        button.classList.toggle('is-active', button === activeButton)
      }
    }

    /**
     * Collapses the Blueprint (left), Selection (right), and Timeline (bottom) panels by default.
     *
     * Note: Rerun's web viewer exposes this via panel overrides rather than a dedicated "default collapsed"
     * configuration knob.
     *
     * @param {import('@rerun-io/web-viewer').WebViewer} viewer - Started Rerun WebViewer instance. (Type: WebViewer, Shape: scalar object)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function applyDefaultCollapsedPanels(
      viewer: import('@rerun-io/web-viewer').WebViewer
    ): void {
      viewer.override_panel_state('blueprint', 'collapsed')
      viewer.override_panel_state('selection', 'collapsed')
      viewer.override_panel_state('time', 'collapsed')
      viewer.toggle_panel_overrides(true)
    }

    /**
     * Ensures the Rerun WebViewer is created and started.
     *
     * @returns {Promise<void>} (Type: Promise<void>, Shape: N/A)
     */
    async function ensureRerunViewerStarted(): Promise<void> {
      if (!rerunRootElement) return

      if (rerunViewerStartPromise) {
        await rerunViewerStartPromise
        return
      }

      const { WebViewer } = await import('@rerun-io/web-viewer')
      rerunViewer = new WebViewer()
      rerunViewer.on('selection_change', (e: unknown) => console.log(e))

      rerunViewerStartPromise = rerunViewer.start(null, rerunRootElement, {
        width: '100%',
        height: '100%',
        hide_welcome_screen: true
      })
      await rerunViewerStartPromise
      if (rerunViewer) applyDefaultCollapsedPanels(rerunViewer)
    }

    /**
     * Aborts any in-flight RRD download and closes the active log channel if present.
     *
     * @returns {void} (Type: void, Shape: N/A)
     */
    function abortOngoingRerunDownload(): void {
      if (rerunDownloadAbortController) {
        rerunDownloadAbortController.abort()
        rerunDownloadAbortController = null
      }
      if (rerunChannel) {
        rerunChannel.close()
        rerunChannel = null
      }
    }

    /**
     * Fully resets the viewer so that only the newly requested recording is visible.
     *
     * @returns {void} (Type: void, Shape: N/A)
     */
    function resetRerunViewer(): void {
      if (rerunViewer) rerunViewer.stop()
      rerunViewer = null
      rerunViewerStartPromise = null
      rerunChannel = null
      if (rerunRootElement) rerunRootElement.innerHTML = ''
    }

    /**
     * Waits until the viewer reports a non-null active recording id.
     *
     * This is used as a robust way to select the newly loaded recording after `send_rrd`,
     * especially when multiple loads happen over time.
     *
     * @param {string} rrdTitle - Display title for the current recording, used for error messages. (Type: string, Shape: scalar)
     * @param {number} timeoutMs - Max time to wait in milliseconds. (Type: number, Shape: scalar)
     * @returns {Promise<string>} Active recording id. (Type: Promise<string>, Shape: scalar)
     */
    async function waitForActiveRecordingId(rrdTitle: string, timeoutMs: number): Promise<string> {
      if (!rerunViewer) throw new Error('Rerun viewer not started.')

      const startMs = performance.now()
      while (performance.now() - startMs < timeoutMs) {
        const recordingId = rerunViewer.get_active_recording_id()
        if (recordingId) return recordingId
        await new Promise((r) => window.setTimeout(r, 50))
      }

      throw new Error(`Timed out waiting for active recording: ${rrdTitle}`)
    }

    /**
     * Activates the given recording in the viewer and seeks to the beginning of its active timeline.
     *
     * @param {string} recordingId - Recording id returned by the viewer. (Type: string, Shape: scalar)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function activateRerunRecording(recordingId: string): void {
      if (!rerunViewer) return
      rerunViewer.set_active_recording_id(recordingId)

      const timeline = rerunViewer.get_active_timeline(recordingId)
      if (!timeline) return

      const timeRange = rerunViewer.get_time_range(recordingId, timeline)
      if (!timeRange) return

      rerunViewer.set_current_time(recordingId, timeline, timeRange.min)
    }

    /**
     * Downloads an RRD file while updating the progress bar.
     *
     * @param {string} rrdUrl - The URL to the `.rrd` file. (Type: string, Shape: scalar)
     * @param {string} rrdTitle - Display title for the current recording. (Type: string, Shape: scalar)
     * @param {AbortSignal} signal - Abort signal for canceling the download. (Type: AbortSignal, Shape: scalar object)
     * @param {number} expectedTotalBytes - Expected total bytes when `Content-Length` is missing (0 if unknown). (Type: number, Shape: scalar)
     * @returns {Promise<Uint8Array>} Downloaded RRD bytes. (Type: Promise<Uint8Array>, Shape: (N,), dtype=uint8)
     */
    async function downloadRrdBytes(
      rrdUrl: string,
      rrdTitle: string,
      signal: AbortSignal,
      expectedTotalBytes: number
    ): Promise<Uint8Array> {
      const response = await fetch(rrdUrl, { signal })
      if (!response.ok) {
        throw new Error(`Failed to fetch RRD: ${response.status} ${response.statusText}`)
      }

      const headerTotalBytes = Number(response.headers.get('content-length') || 0)
      const totalBytesForUi = headerTotalBytes > 0 ? headerTotalBytes : expectedTotalBytes
      if (totalBytesForUi > 0 && rerunProgressElement) {
        rerunProgressElement.max = totalBytesForUi
        rerunProgressElement.value = 0
      } else {
        setRerunProgressIndeterminate()
      }

      if (!response.body) {
        const buffer = await response.arrayBuffer()
        const bytes = new Uint8Array(buffer)
        if (headerTotalBytes > 0 && bytes.byteLength !== headerTotalBytes) {
          throw new Error(
            `RRD download truncated: received ${bytes.byteLength} of ${headerTotalBytes} bytes (${rrdTitle})`
          )
        }
        updateRerunProgress(bytes.byteLength, totalBytesForUi || bytes.byteLength, rrdTitle)
        return bytes
      }

      const reader = response.body.getReader()
      if (headerTotalBytes > 0) {
        const bytes = new Uint8Array(headerTotalBytes)
        let offset = 0
        while (true) {
          const { done, value } = await reader.read()
          if (done) break
          if (!value) continue
          bytes.set(value, offset)
          offset += value.byteLength
          updateRerunProgress(offset, headerTotalBytes, rrdTitle)
        }
        if (offset !== headerTotalBytes) {
          throw new Error(
            `RRD download truncated: received ${offset} of ${headerTotalBytes} bytes (${rrdTitle})`
          )
        }
        return bytes
      }

      const chunks: Uint8Array[] = []
      let loadedBytes = 0
      while (true) {
        const { done, value } = await reader.read()
        if (done) break
        if (!value) continue
        chunks.push(value)
        loadedBytes += value.byteLength
        updateRerunProgress(loadedBytes, totalBytesForUi, rrdTitle)
      }

      const bytes = new Uint8Array(loadedBytes)
      let offset = 0
      for (const chunk of chunks) {
        bytes.set(chunk, offset)
        offset += chunk.byteLength
      }
      return bytes
    }

    /**
     * Lazily loads the Rerun WebViewer, downloads the requested RRD recording with progress,
     * and then opens it in the viewer.
     *
     * This function does not request any RRD files until it is called.
     *
     * @param {string} rrdUrl - The URL to the `.rrd` file. (Type: string, Shape: scalar)
     * @param {string} rrdTitle - Display title for the recording. (Type: string, Shape: scalar)
     * @param {number} expectedTotalBytes - Expected total bytes when `Content-Length` is missing (0 if unknown). (Type: number, Shape: scalar)
     * @returns {Promise<void>} (Type: Promise<void>, Shape: N/A)
     */
    async function loadRerunRecording(
      rrdUrl: string,
      rrdTitle: string,
      expectedTotalBytes: number
    ): Promise<void> {
      if (!rerunRootElement) return

      abortOngoingRerunDownload()
      resetRerunViewer()
      lastRerunProgressPercent = null
      lastRerunProgressHalfMiBStep = null

      setRerunStatus(`Loading: ${rrdTitle}...`)
      setRerunProgressVisible(true)
      setRerunProgressIndeterminate()
      for (const button of rerunButtons) button.disabled = true

      try {
        rerunDownloadAbortController = new AbortController()
        const downloadPromise = downloadRrdBytes(
          rrdUrl,
          rrdTitle,
          rerunDownloadAbortController.signal,
          expectedTotalBytes
        )

        await ensureRerunViewerStarted()
        if (!rerunViewer) return

        rerunChannel = rerunViewer.open_channel(rrdTitle)
        const rrdBytes = await downloadPromise
        rerunChannel.send_rrd(rrdBytes)

        rerunChannel.close()
        rerunChannel = null
        rerunDownloadAbortController = null

        const recordingId = await waitForActiveRecordingId(rrdTitle, 30_000)
        activateRerunRecording(recordingId)
        setRerunStatus(`Loaded: ${rrdTitle}`)
      } catch (err) {
        const errorName = (err as { name?: unknown } | null)?.name
        if (errorName === 'AbortError') {
          setRerunStatus(`Cancelled: ${rrdTitle}`)
        } else {
          const errorMessage = err instanceof Error ? err.message : String(err)
          setRerunStatus(
            errorMessage
              ? `Failed to load: ${rrdTitle} (${errorMessage})`
              : `Failed to load: ${rrdTitle}`
          )
          console.error(err)
        }
      } finally {
        setRerunProgressVisible(false)
        for (const button of rerunButtons) button.disabled = false
      }
    }

    if (rerunButtons.length > 0 && rerunRootElement) {
      for (const button of rerunButtons) {
        button.addEventListener('click', () => {
          rerunRootElement.classList.add('is-visible')
          const rrdTitle = button.dataset.rrdTitle || button.textContent || 'RRD'
          const rrdKey = button.dataset.rrdKey
          const rrdUpstreamUrl = button.dataset.rrdUrl
          const rrdFetchUrl = rrdKey
            ? `/api/dextercap-rrd?key=${encodeURIComponent(rrdKey)}`
            : rrdUpstreamUrl
          const expectedTotalBytes = rrdKey ? (RRD_TOTAL_BYTES_BY_KEY[rrdKey] ?? 0) : 0

          if (!rrdFetchUrl) return
          setActiveRerunButton(button)
          void loadRerunRecording(rrdFetchUrl, rrdTitle, expectedTotalBytes)
        })
      }
    }
    // --- END RERUN (RRD) VIEWER LOGIC ---

    // --- START REPLACEMENT FOR VIDEO GALLERY LOGIC ---
    const galleryVideos = [
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/rubikscube_render.mp4',
        title: "Rubik's Cube",
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/cylinder_render.mp4',
        title: 'Cylinder',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/plate_render.mp4',
        title: 'Plate',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/prism_render.mp4',
        title: 'Prism',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/ring_render.mp4',
        title: 'Ring',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/cuboid_00_render.mp4',
        title: 'Cuboid 0',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/cuboid_01_render.mp4',
        title: 'Cuboid 1',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/cuboid_02_render_1.mp4',
        title: 'Cuboid 2 (1)',
        poster: ''
      },
      {
        src: 'https://cdn.lyt0112.com/Projects/DexterCap/render/cuboid_02_render_2.mp4',
        title: 'Cuboid 2 (2)',
        poster: ''
      }
    ]

    let currentVideoIndex = 0 // Index of the currently displayed video

    const mainVideoElement = document.getElementById('gallery-main-video') as HTMLVideoElement | null
    const mainCaptionElement = document.getElementById('gallery-main-caption') as HTMLElement | null
    const galleryButtons = Array.from(
      document.querySelectorAll<HTMLButtonElement>('#gallery-controls .rerun-load-button')
    )

    /**
     * Updates the active state of the gallery buttons.
     *
     * @param {number} activeIndex - The active gallery video index. (Type: number, Shape: scalar)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function setActiveGalleryButton(activeIndex: number): void {
      for (const button of galleryButtons) {
        const buttonIndex = Number(button.dataset.galleryIndex ?? NaN)
        button.classList.toggle('is-active', Number.isFinite(buttonIndex) && buttonIndex === activeIndex)
      }
    }

    /**
     * Updates the main video player and its caption, then attempts to autoplay.
     *
     * @param {number} index - The index of the video to display from the `galleryVideos` array.
     *                         (Type: number, Shape: scalar)
     * @returns {void} (Type: void, Shape: N/A)
     */
    function updateGalleryVideo(index: number): void {
      if (!mainVideoElement || !mainCaptionElement || index < 0 || index >= galleryVideos.length) {
        return
      }

      const videoData = galleryVideos[index]
      mainVideoElement.pause()
      mainVideoElement.src = videoData.src
      mainVideoElement.poster = videoData.poster || ''
      mainVideoElement.load()
      mainCaptionElement.textContent = videoData.title
      currentVideoIndex = index
      setActiveGalleryButton(index)

      void mainVideoElement.play().catch(() => {
        // Autoplay may be blocked by the browser if it is not muted or not user-initiated.
      })
    }

    // Initialize gallery if required DOM elements are present.
    if (mainVideoElement && mainCaptionElement && galleryVideos.length > 0) {
      updateGalleryVideo(0) // Default: Rubik's Cube

      for (const button of galleryButtons) {
        button.addEventListener('click', () => {
          const targetIndex = Number(button.dataset.galleryIndex ?? NaN)
          if (!Number.isFinite(targetIndex)) return
          if (targetIndex === currentVideoIndex) return
          updateGalleryVideo(targetIndex)
        })
      }
    }
    // --- END REPLACEMENT FOR VIDEO GALLERY LOGIC ---
  })
</script>
