---
title: '[ä¸­æ–‡] Compiler Principles Lab Notes'
publishDate: 2025-01-12 02:15:00
description: "Implement a compiler that compiles SysY language to Koopa IR, finally to RISC-V assembly"
tags:
  - Compiler Principles
  - ç¼–è¯‘åŸç†
  - Course
  - PKU
  - ä¸­æ–‡
heroImage: { src: './cover_imgs/how_compilers_work.png', color: '#64574D' }
language: 'ä¸­æ–‡'
---

import { Aside } from '@/components/user'

## Related Links

- [å®éªŒæ–‡æ¡£](https://pku-minic.github.io/online-doc/#/)
- [å®éªŒè¯„æµ‹å¹³å°](https://course.educg.net/)
- [å®éªŒä»£ç ä¸Šä¼ å¹³å°: GitLab](https://gitlab.eduxiji.net/)
- æœ¬æ–‡æ¡£ä¸­æ‰€æœ‰ä»£ç å‡åœ¨ [æˆ‘çš„ç¼–è¯‘åŸç† Lab ä»“åº“](https://github.com/EmptyBlueBox/Compiler_Principles_Lab-2024Fall-PKU) ä¸­å¼€æº, æ¬¢è¿å¤§å®¶å‚è€ƒ.
- [Arthals çš„ç¼–è¯‘åŸç†èµ„æ–™](https://arthals.ink/tags/ç¼–è¯‘åŸç†)

<Aside title='Why Notes' type='note'>

- è®°å½•ç¼–ç¨‹è¿‡ç¨‹ä¸­çš„æ€è€ƒå’Œç¼–ç è§„èŒƒ, é€šè¿‡åˆ¶å®šæ˜ç¡®çš„åŸåˆ™æ¥æé«˜ä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§, ä¾‹å¦‚å¯„å­˜å™¨å’Œæ ˆçš„ç®¡ç†ç­–ç•¥.
- é€šè¿‡å…·ä½“ç¤ºä¾‹å±•ç¤ºä¸€äº›æœ€ä½³å®è·µ, è‡´åŠ›äº**åœ¨ä»£ç æŠ½è±¡ç¨‹åº¦å’Œå¯è¯»æ€§ä¹‹é—´å¯»æ±‚å¹³è¡¡**, ä»¥å®ç°é€»è¾‘ç®€æ´æ€§å’Œä»£ç å¯ç†è§£æ€§çš„ç»Ÿä¸€.
- è¡¥å……å®éªŒæ–‡æ¡£ä¸­æœªè¯¦ç»†è¯´æ˜çš„é—®é¢˜åŠå…¶è§£å†³æ–¹æ¡ˆ, ä¸ºåç»­å®éªŒè€…æä¾›å‚è€ƒ.

</Aside>

ä»¥ä¸‹æ˜¯ä¸€äº›å°å»ºè®®~

<Aside title='General Best Practice' type='tip'>

- ä¸€ä¸ªè¾ƒå®¹æ˜“çš„å®Œæˆ Lab çš„æ–¹æ³•æ˜¯åœ¨å†™æ¯ä¸€ä¸ª Lab `x` çš„æ—¶å€™, å°†æˆ‘çš„ (æˆ–è€…åˆ«äººçš„) Lab `x-1` å’Œ Lab `x` çš„ä»£ç è¿›è¡Œå¯¹æ¯”, æ¯”å¦‚ `VSCode` çš„ `compare selected` åŠŸèƒ½, ç„¶ååœ¨è‡ªå·±çš„ Lab `x-1` çš„åŸºç¡€ä¸Šå†™ Lab `x` çš„ä»£ç  (è€Œä¸æ˜¯æŠ„è¢­åˆ«äººçš„ Lab `x` çš„ä»£ç ) , è¿™æ ·èƒ½ä¿è¯è€ƒè™‘åˆ°æ‰€æœ‰çš„é€»è¾‘, å¤§å¹…å‡å°‘ debug çš„æ—¶é—´, è¿˜èƒ½é”»ç‚¼è‡ªå·±é˜…è¯»ä»£ç çš„èƒ½åŠ› ğŸŒšğŸ‘ŠğŸ‘ŠğŸ‘ŠğŸ‘ŠğŸ‘Š.
- æ¯ä¸€ä¸ª Level çš„æµ‹è¯•ç‚¹åœ¨ä½ å®ç°æ­£ç¡®çš„æƒ…å†µä¸‹éƒ½æ˜¯å¯ä»¥å…¨éƒ¨é€šè¿‡çš„, å¦‚æœä½ æ²¡æœ‰é€šè¿‡è¯´æ˜ä½ çš„é€»è¾‘å­˜åœ¨é—®é¢˜, ä¸å­˜åœ¨éœ€è¦åé¢çš„ç‰¹æ€§æ‰èƒ½è§£å†³å‰é¢æµ‹è¯•ç‚¹çš„æƒ…å†µ.
- å¼ºçƒˆå»ºè®®å¤§å®¶åœ¨å¤§å››æ²¡æœ‰ç»©ç‚¹å‹åŠ›çš„æ—¶å€™é€‰è¿™é—¨è¯¾!
    - è¿™æ ·æœ€åå¯ä»¥æ”¾æ‰ Lv9 ä¸å®Œæˆ, å› ä¸º Lv9 éå¸¸æµªè´¹æ—¶é—´å¹¶ä¸”å æ‰€æœ‰ Lab çš„ `27%` çš„åˆ†æ•°, ä¹Ÿå°±æ˜¯æ€»è¯„çš„ 8 åˆ†, å¦‚æœä½ åœ¨ç»©ç‚¹å‹åŠ›ä¸‹å®Œæˆæ‰€æœ‰ Lab ä¼šæµªè´¹å¾ˆå¤šæ—¶é—´.

</Aside>

## Lv 0

### Prepare Environment

é¦–å…ˆå®‰è£…å¹¶è¿è¡Œ [Docker](https://www.docker.com/) .

æ‹‰å–é•œåƒ:

```bash
docker pull maxxing/compiler-dev
```

ä½¿ç”¨é•œåƒåˆ›å»ºå®¹å™¨:

```bash
docker run -it --name compiler -v <compiler_lab_path>:/root/compiler maxxing/compiler-dev bash
```

å…¶ä¸­å‚æ•°çš„å«ä¹‰:

- `-it` è¡¨ç¤ºä»¥äº¤äº’æ¨¡å¼è¿è¡Œå®¹å™¨.
- `--name compiler` è¡¨ç¤ºå°†å®¹å™¨é‡å‘½åä¸º `compiler`.
- `-v <compiler_lab_path>:/root/compiler` è¡¨ç¤ºå°†å®¿ä¸»æœºçš„ç¼–è¯‘ Lab é¡¹ç›®æ–‡ä»¶å¤¹æŒ‚è½½åˆ°å®¹å™¨ä¸­.
- `maxxing/compiler-dev` è¡¨ç¤ºä½¿ç”¨ `maxxing` æä¾›çš„ `compiler-dev` é•œåƒ.
- `bash` è¡¨ç¤ºä»¥ `bash` ä¸ºå¯åŠ¨å‘½ä»¤.

åšä¸»çš„ç¼–è¯‘é¡¹ç›®ç»“æ„ç±»ä¼¼è¿™æ ·, å…¶ä¸­ `~/Documents/xxx/Lv7` å°±æ˜¯ä½ çš„å®¿ä¸»æœºç¼–è¯‘ Lab é¡¹ç›®æ–‡ä»¶å¤¹:

```bash
Mac OS 1926-08-17 12:00:00
emptyblue ~/Documents/xxx/Lv7
â¯ tree 

.
â”œâ”€â”€ CMakeLists.txt
â””â”€â”€ src
    â”œâ”€â”€ include
    â”‚Â Â  â”œâ”€â”€ koopa.h
    â”‚Â Â  â”œâ”€â”€ koopa.hpp
    â”‚Â Â  â”œâ”€â”€ koopa_util.hpp
    â”‚Â Â  â”œâ”€â”€ riscv.hpp
    â”‚Â Â  â””â”€â”€ riscv_util.hpp
    â”œâ”€â”€ koopa.cpp
    â”œâ”€â”€ koopa_util.cpp
    â”œâ”€â”€ main.cpp
    â”œâ”€â”€ riscv.cpp
    â”œâ”€â”€ riscv_util.cpp
    â”œâ”€â”€ sysy.l
    â””â”€â”€ sysy.y

3 directories, 13 files
```

<Aside title='LLDB Issue' type='caution'>

å¦‚æœé MacOS, å¯ä»¥åŠ å…¥ `--cap-add=SYS_PTRACE --security-opt seccomp=unconfined` è¡¨ç¤ºæ·»åŠ  `SYS_PTRACE` æƒé™, å–æ¶ˆ seccomp é™åˆ¶, ä»¥æ–¹ä¾¿ä½¿ç”¨ `LLDB` åœ¨ Docker ä¸­è°ƒè¯•.

ä½†æ˜¯æˆ‘æ²¡æœ‰æ‰¾åˆ°æ–¹æ³•åœ¨ MacOS ä¸Šçš„ Docker ä¸­è¿è¡Œ `LLDB`, å¦‚æœä½ æ‰¾åˆ°äº†å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜çš„åŠæ³•, å¯ä»¥åœ¨ä¸‹é¢å†™ä¸€ä¸ªè¯„è®º!

2024-12-23 Update:

ä¼¼ä¹åŠ©æ•™çš„å®éªŒæ–‡æ¡£æåŠäº†å¦‚ä½•è°ƒè¯•: [è°ƒè¯• risc-v ç¨‹åº](https://pku-minic.github.io/online-doc/#/misc-app-ref/environment?id=è°ƒè¯•-risc-v-ç¨‹åº)

</Aside>

æ¯æ¬¡éœ€è¦è¿›å…¥å®¹å™¨æ—¶, å…ˆå¯åŠ¨å®¹å™¨, å†è¿›å…¥:

```bash
docker start compiler
docker exec -it compiler bash
```

é€€å‡ºå®¹å™¨ (Control + D):

```bash
exit
```

æŸ¥çœ‹æ‰€æœ‰å®¹å™¨:

```bash
docker ps -a
```

åœæ­¢æ‰€æœ‰å®¹å™¨:

```bash
docker stop $(docker ps -aq)
```

åˆ é™¤ `compiler` å®¹å™¨:

```bash
docker rm -f compiler
```

åˆ é™¤æ‰€æœ‰å®¹å™¨:

```bash
docker rm $(docker ps -aq)
```

### Compile and Test

è¯·ä»”ç»†é˜…è¯» [å®éªŒç¯å¢ƒä½¿ç”¨è¯´æ˜](https://pku-minic.github.io/online-doc/#/misc-app-ref/environment) .

ä½¿ç”¨ `cmake` ç”Ÿæˆ Makefile æ–‡ä»¶, æŒ‡å®šç¼–è¯‘ç±»å‹ä¸º `Debug`:

```bash
cmake -DCMAKE_BUILD_TYPE=Debug -B build
```

ä½¿ç”¨ `cmake` ç”Ÿæˆ Makefile æ–‡ä»¶, ä¸æŒ‡å®šç¼–è¯‘ç±»å‹:

```bash
cmake -B build
```

ä½¿ç”¨ `cmake` ç¼–è¯‘:

```bash
cmake --build build
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv<lv_number> /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv<lv_number> /root/compiler
```

å¦‚æœæœ¬åœ°æµ‹è¯•ä¸é€šè¿‡, å¯ä»¥æŠŠ `/opt/bin/testcases` ä¸­çš„æµ‹è¯•ç”¨ä¾‹å¤åˆ¶åˆ°å½“å‰è·¯å¾„è¿›è¡ŒæŸ¥çœ‹è°ƒè¯•.

```bash
cp -r /opt/bin/testcases .
```

å¦‚æœæƒ³æµ‹è¯•è‡ªå·±çš„æµ‹è¯•ç”¨ä¾‹, å¯ä»¥å°†è‡ªå·±çš„æµ‹è¯•ç”¨ä¾‹æ‰€åœ¨çš„ç›®å½•ä¼ ç»™ `autotest` å‘½ä»¤, æ¯”å¦‚:

```bash
autotest -t <test_case_dir> /root/compiler
```

<Aside title='Your Test Case' type='tip'>

æ³¨æ„æ¯ä¸€ä¸ª Test Case åŒ…å«ä¸¤ä¸ªåç§°ç›¸åŒçš„ `.c` å’Œ `.out` æ–‡ä»¶, å…¶ä¸­ `.c` æ˜¯è¾“å…¥ç»™ç¼–è¯‘å™¨çš„ä»£ç , `.out` æ˜¯ä½ çš„ç¼–è¯‘å™¨åº”è¯¥è¿”å›çš„ç»“æœ.

</Aside>

## Lv 1

Lab çš„ç¬¬ä¸€ä¸ª checkpoint è¦æ±‚å¤§å®¶å®Œæˆç¼–è¯‘å™¨çš„åŸºç¡€é€»è¾‘ç»“æ„æ­å»º, åŒ…æ‹¬:

- è¯æ³•åˆ†æå™¨çš„é€»è¾‘
- è¯­æ³•åˆ†æå™¨çš„é€»è¾‘
- ç®€å•çš„ä¸­é—´ä»£ç  `Koopa` ç”Ÿæˆå™¨

æˆ‘ä½¿ç”¨çš„æ˜¯ CMake ä½œä¸ºæ„å»ºç³»ç»Ÿ, é‡‡ç”¨äº† [åŸºäº CMake çš„ SysY ç¼–è¯‘å™¨é¡¹ç›®æ¨¡æ¿](https://github.com/pku-minic/sysy-cmake-template) çš„ç»“æ„.

å¯ä»¥å…ˆæŠŠ[å®éªŒæ–‡æ¡£](https://pku-minic.github.io/online-doc/#/)ä¸­ `Lv 1` ä¸­ç»™å‡ºçš„ä»£ç å¤åˆ¶ä¸‹æ¥ä½œä¸º `codebase` .

### Lexer

æˆ‘ä»¬åªéœ€è¦åœ¨ `src/sysy.l` ä¸­å†™ä¸€æ®µä»£ç è¯´æ˜å¦‚ä½•å®šä¹‰ Token ç±»å‹, å¦‚ä½•æŠŠè¯»åˆ°çš„å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•´æ•°æˆ–è€…æµ®ç‚¹æ•°, ç„¶åå°±å¯ä»¥ä½¿ç”¨ `flex` è¯»å…¥ `src/sysy.l` æ¥ç”Ÿæˆè¯æ³•åˆ†æå™¨, æ‰€ä»¥å®é™…ä¸Šä¸ç”¨è‡ªå·±å†™ä¸€ä¸ªè¯æ³•åˆ†æå™¨.

<Aside title='Flex' type='note'>

`flex` çš„è¾“å…¥æ–‡ä»¶çš„è¯­æ³•è§„åˆ™å¯ä»¥å‚è€ƒ[å®éªŒæ–‡æ¡£å¯¹åº”ç« èŠ‚](https://pku-minic.github.io/online-doc/#/lv1-main/lexer-parser) .

</Aside>

ç¤ºä¾‹:

```asm
"int"           { return INT; }
"return"        { return RETURN; }
{Identifier}    { yylval.str_val = new string(yytext); return IDENT; }
{Decimal}       { yylval.int_val = strtol(yytext, nullptr, 0); return INT_CONST; }
```

å…¶ä¸­ `INT`, `RETURN`, `IDENT` ç­‰è¿”å›å€¼, å…¶å®æ˜¯ Bison ç”Ÿæˆçš„å›ºå®šæšä¸¾ç±»å‹å€¼, å°±æ˜¯ä¸€ä¸ªæ•´æ•°.

æ‰€ä»¥è¿™æ®µä»£ç ä»£è¡¨çš„å«ä¹‰ä¸º:

- `"int"` å’Œ `"return"` æ˜¯æ­£åˆ™è¡¨è¾¾å¼, è¿™å°±æ˜¯å‘Šè¯‰å½“åŒ¹é…åˆ°è¿™äº›å­—ç¬¦ä¸²æ—¶, è¿”å›ç»™è¯­æ³•åˆ†æå™¨ `INT` å’Œ `RETURN` ç±»å‹, å‘Šè¯‰è¯­æ³•åˆ†æå™¨è¿™æ˜¯ä¸€ä¸ªä¿ç•™å­—.
- `{Identifier}` æ˜¯ä¸Šé¢å®šä¹‰å¥½çš„æ­£åˆ™è¡¨è¾¾å¼, å½“è¿™ä¸ªè¡¨è¾¾å¼åŒ¹é…åˆ°æŸä¸ªå­—ç¬¦ä¸²æ—¶, å°†è¿™ä¸ªå­—ç¬¦ä¸²èµ‹å€¼ç»™è¯­æ³•åˆ†æå™¨å®šä¹‰çš„ `yylval.str_val` å˜é‡, ç„¶åè¿”å›ç»™è¯­æ³•åˆ†æå™¨ `IDENT` ç±»å‹, å‘Šè¯‰è¯­æ³•åˆ†æå™¨è¿™æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦, æ¯”å¦‚å‡½æ•°å, è¯­æ³•åˆ†æå™¨çŸ¥é“ç°åœ¨è¯»å–åˆ°äº†ä¸€ä¸ªæ ‡è¯†ç¬¦, å°±ä» `yylval.str_val` ä¸­å–å‡ºè¿™ä¸ªå­—ç¬¦ä¸².
- `{Decimal}` æ˜¯ä¸Šé¢å®šä¹‰å¥½çš„æ­£åˆ™è¡¨è¾¾å¼, å½“è¿™ä¸ªè¡¨è¾¾å¼åŒ¹é…åˆ°æŸä¸ªå­—ç¬¦ä¸²æ—¶, å°†è¿™ä¸ªå­—ç¬¦ä¸²èµ‹å€¼ç»™è¯­æ³•åˆ†æå™¨å®šä¹‰çš„ `yylval.int_val` å˜é‡, ç„¶åè¿”å›ç»™è¯­æ³•åˆ†æå™¨ `INT_CONST` ç±»å‹, å‘Šè¯‰è¯­æ³•åˆ†æå™¨è¿™æ˜¯ä¸€ä¸ªæ•´æ•°å¸¸é‡, è¯­æ³•åˆ†æå™¨çŸ¥é“ç°åœ¨è¯»å–åˆ°äº†ä¸€ä¸ªæ•´æ•°å¸¸é‡, å°±ä» `yylval.int_val` ä¸­å–å‡ºè¿™ä¸ªæ•´æ•°.

### Parser

æˆ‘ä»¬åªéœ€è¦åœ¨ `src/sysy.y` ä¸­å†™ä¸€æ®µä»£ç è¯´æ˜å¦‚ä½•å®šä¹‰è¯­æ³•è§„åˆ™, æ¯”å¦‚ä¸€ä¸ªå‡½æ•°æ˜¯å¦‚ä½•ç”±å‡½æ•°ç±»å‹, å‡½æ•°å, å˜é‡å£°æ˜åˆ—è¡¨å’Œå‡½æ•°ä½“ç»„æˆçš„, ç„¶åå°±å¯ä»¥ä½¿ç”¨ `bison` è¯»å…¥ `src/sysy.y` æ¥ç”Ÿæˆè¯­æ³•åˆ†æå™¨.

è§„çº¦ç¤ºä¾‹:

```asm
FuncDef
  : FuncType IDENT '(' ')' Block {
    auto ast = new FuncDefAST();
    ast->func_type = unique_ptr<BaseAST>($1);
    ast->ident = *unique_ptr<string>($2);
    ast->block = unique_ptr<BaseAST>($5);
    $$ = ast;
  }
```

- å…¶ä¸­ `FuncDefAST` ç­‰ç±»æ˜¯ `include/ast.hpp` ä¸­ç”±ä½ å®šä¹‰å¥½çš„, å…¶ä¸­åŒ…æ‹¬äº†æ¯ä¸ªè¯­æ³•è§„åˆ™åŒ…å«çš„è¯­æ³•å•å…ƒ, æ¯”å¦‚ `FuncDef` è¯­æ³•è§„åˆ™åŒ…å« `FuncType`, `IDENT`, `Block` ç­‰è¯­æ³•å•å…ƒ, è¯­æ³•åˆ†æå™¨ç°åœ¨ä½¿ç”¨è¿™äº›ç±»æ¥æ„é€ æŠ½è±¡è¯­æ³•æ ‘.
- `$1` æ˜¯ä»£è¡¨å­è¯­æ³•å•å…ƒçš„å˜é‡, æ¯”å¦‚ `FuncDef` è¯­æ³•è§„åˆ™çš„ç¬¬ä¸€ä¸ªå­è¯­æ³•å•å…ƒæ˜¯ `FuncType`, é‚£ä¹ˆ `$1` å°±ä»£è¡¨ `FuncType`, è¯­æ³•åˆ†æå™¨é€’å½’åœ°ä» `FuncType` ç»§ç»­è§„çº¦, æ³¨æ„è¿™é‡Œçš„å˜é‡æ ‡å·æ˜¯ä» 1 å¼€å§‹çš„.
- `$$ = ast;` æ˜¯å‘Šè¯‰è¯­æ³•åˆ†æå™¨, `FuncDef` è¯­æ³•è§„åˆ™è§„çº¦çš„ç»“æœæ˜¯ä¸€ä¸ª `FuncDefAST` ç±», è¯­æ³•åˆ†æå™¨ç°åœ¨çŸ¥é“ `FuncDef` è¯­æ³•è§„åˆ™è§„çº¦çš„ç»“æœ `FuncDefAST` ç±»ä¸­éƒ½æ˜¯ä»€ä¹ˆæ•°æ®äº†.

### `Koopa IR` Generation

å½“è¯­æ³•åˆ†æå™¨è§„çº¦å‡ºæŠ½è±¡è¯­æ³•æ ‘å, æˆ‘ä»¬å°±å¯ä»¥éå†æŠ½è±¡è¯­æ³•æ ‘, é‡åˆ°å¶å­èŠ‚ç‚¹å°± `print` , éå†ç»“æŸå°±ç”Ÿæˆäº†ä¸­é—´ä»£ç  `Koopa`.

åœ¨ `main.cpp` ä¸­å®šä¹‰ç¼–è¯‘å™¨æœ¬èº«çš„ `main` å‡½æ•°, è¯»å…¥éœ€è¦ç¼–è¯‘çš„æºæ–‡ä»¶, è°ƒç”¨è¯æ³•åˆ†æå™¨å’Œè¯­æ³•åˆ†æå™¨, å¾—åˆ°æ”¾å¥½æ•°æ®çš„æŠ½è±¡è¯­æ³•æ ‘, ç„¶åè°ƒç”¨è¯­æ³•æ ‘ç±»ä¸­å®šä¹‰å¥½çš„ `print` å‡½æ•°ç”Ÿæˆä¸­é—´ä»£ç  `Koopa`. 

æˆ‘çš„å…·ä½“ç»“æ„å®‰æ’æ˜¯:

- åœ¨ `main.cpp` ä¸­å®šä¹‰ç¼–è¯‘å™¨æœ¬èº«çš„ `main` å‡½æ•°, è¯»å…¥éœ€è¦ç¼–è¯‘çš„æºæ–‡ä»¶, è°ƒç”¨è¯æ³•åˆ†æå™¨å’Œè¯­æ³•åˆ†æå™¨, å¾—åˆ°æ”¾å¥½æ•°æ®çš„æŠ½è±¡è¯­æ³•æ ‘, ç„¶åè°ƒç”¨è¯­æ³•æ ‘ç±»ä¸­å®šä¹‰å¥½çš„ `print` å‡½æ•°ç”Ÿæˆä¸­é—´ä»£ç  `Koopa`.
- åœ¨ `include/ast.hpp` ä¸­å®šä¹‰æŠ½è±¡è¯­æ³•æ ‘çš„èŠ‚ç‚¹ç±», æ¯ä¸ªèŠ‚ç‚¹ç±»ä¸­å®šä¹‰ä¸€ä¸ª `print` å‡½æ•°, ç”¨äºç”Ÿæˆä¸­é—´ä»£ç  `Koopa` æˆ– Debug ä¿¡æ¯.
- åœ¨ `ast.cpp` ä¸­å®šä¹‰æŠ½è±¡è¯­æ³•æ ‘çš„å„ä¸ªèŠ‚ç‚¹ç±», å¹¶å®ç° `print` å‡½æ•°.

### Incomplete Parts of the Codebase

åœ¨ handout ç»™å‡ºçš„ codebase ä¸­, è¯æ³•åˆ†æå™¨å’Œè¯­æ³•åˆ†æå™¨å¤§éƒ¨åˆ†å·²ç»å†™å¥½äº†, ä½†æ˜¯è¿˜æœ‰ä¸€äº›éœ€è¦ä¿®æ”¹çš„åœ°æ–¹:

- åœ¨ `src/sysy.y` ä¸­, éœ€è¦åŠ å…¥ `include/ast.hpp` çš„å¼•ç”¨, å¦åˆ™è¯­æ³•åˆ†æå™¨ä¼šæ‰¾ä¸åˆ°ä½ å®šä¹‰çš„æŠ½è±¡è¯­æ³•æ ‘çš„èŠ‚ç‚¹ç±», å°±ä¸èƒ½æŠŠæ•°æ®å†™åˆ°ä½ å®šä¹‰çš„æŠ½è±¡è¯­æ³•æ ‘ä¸­.
- åœ¨ `include/ast.hpp` ä¸­, éœ€è¦å®šä¹‰ç¤ºä¾‹ä»£ç ä¸­æ²¡æœ‰ç»™å‡ºçš„æŠ½è±¡è¯­æ³•æ ‘çš„èŠ‚ç‚¹ç±», å¹¶å®šä¹‰ `print` å‡½æ•°.
- åœ¨ `ast.cpp` ä¸­, éœ€è¦å®ç°ç¤ºä¾‹ä»£ç ä¸­æ²¡æœ‰å®ç°çš„æŠ½è±¡è¯­æ³•æ ‘çš„å„ä¸ªèŠ‚ç‚¹ç±», å¹¶å®ç° `print` å‡½æ•°.

<Aside title='BlockComment' type='tip'>

ç¡®ä¿åœ¨ `src/sysy.l` ä¸­å®šä¹‰æ­£ç¡®çš„ BlockComment çš„æ­£åˆ™è¡¨è¾¾å¼, å¦åˆ™æœ‰ä¸€äº›æµ‹è¯•ç‚¹ä¸é€šè¿‡.

</Aside>

å¥½çš„, ç°åœ¨å·²ç»å®Œæˆäº†ç¼–è¯‘å™¨çš„åŸºç¡€é€»è¾‘ç»“æ„æ­å»º!

### Compile and Test

**ä»¥ä¸‹å‡é»˜è®¤ä½ å·²ç»è¿›å…¥å®¹å™¨, å¹¶ä¸”å½“å‰ç›®å½•ä¸ºç¼–è¯‘ Lab çš„ä¸€çº§ç›®å½•.**

ä½¿ç”¨ `cmake` ç”Ÿæˆ Makefile æ–‡ä»¶:

```bash
cmake -DCMAKE_BUILD_TYPE=Debug -B build
```

ä½¿ç”¨ `cmake` ç¼–è¯‘:

```bash
cmake --build build
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹:

```bash
autotest -koopa -s lv1 /root/compiler
```

å¦‚æœæœ¬åœ°æµ‹è¯•ä¸é€šè¿‡, å¯ä»¥æŠŠ `/opt/bin/testcases` ä¸­çš„æµ‹è¯•ç”¨ä¾‹å¤åˆ¶åˆ°å½“å‰è·¯å¾„è¿›è¡ŒæŸ¥çœ‹è°ƒè¯•.

```bash
cp -r /opt/bin/testcases .
```

## Lv 2

é¦–å…ˆå›é¡¾ä¸€ä¸‹ç¼–è¯‘å™¨çš„ä¸‰å±‚ç»“æ„:

<Aside title='Compiler Structure' type='note'>

- **å‰ç«¯**: é€šè¿‡è¯æ³•åˆ†æå’Œè¯­æ³•åˆ†æ, å°†æºä»£ç è§£ææˆæŠ½è±¡è¯­æ³•æ ‘ (abstract syntax tree, AST). é€šè¿‡è¯­ä¹‰åˆ†æ, æ‰«ææŠ½è±¡è¯­æ³•æ ‘, æ£€æŸ¥å…¶æ˜¯å¦å­˜åœ¨è¯­ä¹‰é”™è¯¯.
- **ä¸­ç«¯**: å°†æŠ½è±¡è¯­æ³•æ ‘è½¬æ¢ä¸ºä¸­é—´è¡¨ç¤º (intermediate representation, IR), å¹¶åœ¨æ­¤åŸºç¡€ä¸Šå®Œæˆä¸€äº›æœºå™¨æ— å…³ä¼˜åŒ–.
- **åç«¯**: å°†ä¸­é—´è¡¨ç¤ºè½¬æ¢ä¸ºç›®æ ‡å¹³å°çš„æ±‡ç¼–ä»£ç , å¹¶åœ¨æ­¤åŸºç¡€ä¸Šå®Œæˆä¸€äº›æœºå™¨ç›¸å…³ä¼˜åŒ–.

</Aside>

åœ¨ Lv 1 ä¸­å·²ç»å®Œæˆäº†å‰ç«¯å’Œä¸­ç«¯, ç°åœ¨æ¥å®Œæˆåç«¯.

è™½è¯´æ˜¯å®Œæˆåç«¯, ä½†æ˜¯å®é™…ä¸ŠåŠ©æ•™å›¢é˜Ÿå·²ç»å¸®åŠ©å®ç°å¥½äº†èƒ½å¤Ÿå¤„ç† Koopa IR çš„åº“, æˆ‘ä»¬åªéœ€è¦è°ƒç”¨ä»–ä»¬æä¾›çš„åº“ (å³è°ƒç”¨ `koopa.h` ä¸­å®šä¹‰çš„å‡½æ•°) å°±å¯ä»¥å®Œæˆåç«¯çš„å¤§éƒ¨åˆ†å®ç°äº†, æˆ‘ä»¬åªéœ€è¦è‡ªå·±å®ç° `RISC-V` æ±‡ç¼–ä»£ç çš„è¾“å‡ºå°±å¯ä»¥äº†.

å…·ä½“å¦‚ä½•è°ƒç”¨, å‚é˜… [å®éªŒæ–‡æ¡£](https://pku-minic.github.io/online-doc/#/lv2-code-gen/processing-ir) æŠŠä»£ç å¤åˆ¶ä¸‹æ¥å³å¯.

æœ€åçš„åç«¯ä»£ç å…¥å£åº”è¯¥ç±»ä¼¼:

```cpp
#include "include/backend.hpp"

int backend(const char *koopa_str)
{
    // è§£æå­—ç¬¦ä¸² str, å¾—åˆ° Koopa IR ç¨‹åº
    koopa_program_t program;
    koopa_error_code_t ret = koopa_parse_from_string(koopa_str, &program);
    assert(ret == KOOPA_EC_SUCCESS); // ç¡®ä¿è§£ææ—¶æ²¡æœ‰å‡ºé”™
    // åˆ›å»ºä¸€ä¸ª raw program builder, ç”¨æ¥æ„å»º raw program
    koopa_raw_program_builder_t builder = koopa_new_raw_program_builder();
    // å°† Koopa IR ç¨‹åºè½¬æ¢ä¸º raw program
    koopa_raw_program_t raw = koopa_build_raw_program(builder, program);
    // é‡Šæ”¾ Koopa IR ç¨‹åºå ç”¨çš„å†…å­˜
    koopa_delete_program(program);

    // å¤„ç† raw program
    visit(raw);

    // å¤„ç†å®Œæˆ, é‡Šæ”¾ raw program builder å ç”¨çš„å†…å­˜
    // æ³¨æ„, raw program ä¸­æ‰€æœ‰çš„æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜å‡ä¸º raw program builder çš„å†…å­˜
    // æ‰€ä»¥ä¸è¦åœ¨ raw program å¤„ç†å®Œæ¯•ä¹‹å‰é‡Šæ”¾ builder
    koopa_delete_raw_program_builder(builder);

    return 0;
}

void visit(const koopa_raw_slice_t &slice)
{
  // ...
}

void visit(const koopa_raw_program_t &program)
{
  // ...
}

// ...
```

### Traverse the Abstract Syntax Tree

è°ƒç”¨åº“ä¹‹åæˆ‘ä»¬å°±å¾—åˆ°äº†ä»¥æŠ½è±¡è¯­æ³•æ ‘å½¢å¼è¡¨ç¤ºçš„ `RISC-V` æ±‡ç¼–ä»£ç , ç°åœ¨éœ€è¦ DFS éå†è¿™æ£µæŠ½è±¡è¯­æ³•æ ‘, å°†å…¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶è¾“å‡º, æˆ‘ä»¬é€‰æ‹©ä½¿ç”¨å‡½æ•°é€’å½’çš„æ–¹å¼æ¥éå†è¿™æ£µæŠ½è±¡è¯­æ³•æ ‘, å…·ä½“å¦‚ä½•éå†å¯ä»¥å‚è€ƒå®éªŒæ–‡æ¡£, è¿™é‡Œä¸å†èµ˜è¿°, ä½†æ˜¯æœ‰ä¸€äº› high level çš„ idea å¯ä»¥å¸®åŠ©ä½ ç†è§£è¿™é¢—æ ‘ä¸Šçš„å„ç§åŠ©æ•™å®šä¹‰çš„ type.

è¿™é¢—è¯­æ³•æ ‘çš„èŠ‚ç‚¹å¤§è‡´æ˜¯ `program`, `function`, `basic_block`, `value`, è¿™äº›èŠ‚ç‚¹å¾ˆå¤šéƒ½åŒ…å«åŒç±»å‹çš„ä¸œè¥¿, æ¯”å¦‚ä¸€ä¸ªç¨‹åºæœ‰å¾ˆå¤šçš„å‡½æ•°, ä¸€ä¸ªå‡½æ•°æœ‰å¾ˆå¤šçš„åŸºæœ¬å—, ä¸€ä¸ªåŸºæœ¬å—æœ‰å¾ˆå¤šæŒ‡ä»¤, é‚£ä¹ˆæ¯”å¦‚ `program` è¿™ä¸ªèŠ‚ç‚¹çš„è¿™ä¸€å †å‡½æ•°å°±ä¼šå­˜åœ¨**ä¸€ä¸ª** `koopa_raw_slice_t` ç±»å‹ä¸­, æ‰€ä»¥å¯¹äºä¸€ä¸ª `program` èŠ‚ç‚¹ä¸­çš„æ‰€æœ‰å‡½æ•°, åªéœ€è¦å¯¹åŒ…å«è¿™äº›å‡½æ•°çš„è¿™ä¸€ä¸ª `koopa_raw_slice_t` è°ƒç”¨ä¸€æ¬¡ `visit` å‡½æ•°å³å¯, å¦‚ä¸‹æ‰€ç¤º, `visit` å‡½æ•°ä¼šæŠŠè¿™ä¸€å †ä¸œè¥¿é€ä¸ªå¸®ä½ è®¿é—®.

```cpp
void visit(const koopa_raw_slice_t &slice)
{
    for (size_t i = 0; i < slice.len; ++i)
    {
        auto ptr = slice.buffer[i];
        // æ ¹æ® slice çš„ kind å†³å®šå°† ptr è§†ä½œä½•ç§å…ƒç´ 
        switch (slice.kind)
        {
        case KOOPA_RSIK_FUNCTION:
            // è®¿é—®å‡½æ•°
            visit(reinterpret_cast<koopa_raw_function_t>(ptr));
            break;
        case KOOPA_RSIK_BASIC_BLOCK:
            // è®¿é—®åŸºæœ¬å—
            visit(reinterpret_cast<koopa_raw_basic_block_t>(ptr));
            break;
        case KOOPA_RSIK_VALUE:
            // è®¿é—®æŒ‡ä»¤
            visit(reinterpret_cast<koopa_raw_value_t>(ptr));
            break;
        default:
            // æˆ‘ä»¬æš‚æ—¶ä¸ä¼šé‡åˆ°å…¶ä»–å†…å®¹, äºæ˜¯ä¸å¯¹å…¶åšä»»ä½•å¤„ç†
            assert(false);
        }
    }
}
```

è®¿é—® `koopa_raw_value_t` ç±»å‹çš„å‡½æ•°å¤§è‡´å¦‚ä¸‹æ‰€ç¤º, `koopa_raw_value_t` ç±»å‹æ˜¯ä¸€ä¸ªæŒ‡é’ˆ, è¿™ä¸ªæŒ‡é’ˆå¯ä»¥æŒ‡å‘ `RISC-V` æ±‡ç¼–ä»£ç çš„ä¸€ä¸ªå€¼ (ä¸€æ¡æŒ‡ä»¤çš„ç»“æœå¯ä»¥ä»£è¡¨è¿™ä¸ªæŒ‡ä»¤, æ‰€ä»¥ä¸€æ¡æŒ‡ä»¤ä¹Ÿç®—ä¸€ä¸ªå€¼) .

å¦‚æœç¢°ä¸Šä»£è¡¨ä¸€ä¸ªæŒ‡ä»¤, å°±å¯èƒ½é‡å¤è°ƒç”¨ `visit koopa_raw_value_t` ä¸¤æ¬¡, å› ä¸ºæŒ‡ä»¤ä¸­åŒ…å«å€¼, æ¯”å¦‚è°ƒç”¨ `visit koopa_raw_value_t` æ—¶å‘ç°è¿™æ˜¯ä¸€ä¸ªè¿”å›æŒ‡ä»¤, å°±è°ƒç”¨ `visit koopa_raw_return_t` , è¿”å›å€¼å°±ä¼šéœ€è¦å†è°ƒç”¨ä¸€æ¬¡ `visit koopa_raw_value_t`.

```cpp
void visit(const koopa_raw_value_t &value)
{
    // æ ¹æ®æŒ‡ä»¤ç±»å‹åˆ¤æ–­åç»­éœ€è¦å¦‚ä½•è®¿é—®
    const auto &kind = value->kind;
    switch (kind.tag)
    {
    case KOOPA_RVT_RETURN:
        // è®¿é—® return æŒ‡ä»¤
        visit(kind.data.ret);
        break;
    case KOOPA_RVT_INTEGER:
        // è®¿é—® integer æŒ‡ä»¤
        visit(kind.data.integer, value);
        break;
    // ...
    default:
        // å…¶ä»–ç±»å‹æš‚æ—¶é‡ä¸åˆ°
        throw std::runtime_error("visit: invalid instruction");
    }
}
```

### Link Middleend and Backend

ä¸æ­¤åŒæ—¶, ä½ è¿˜éœ€è¦å°†ä½ åœ¨ Lv 1 ä¸­è¾“å‡ºçš„ `Koopa IR` è¾“å…¥ç»™åç«¯, åœ¨è¿™é‡Œæˆ‘æ¨èä½¿ç”¨ `std::stringstream` ç±»å‹æ¥å­˜å‚¨ `Koopa IR`, ç„¶åäº¤ç»™åç«¯å³å¯, å®ç°ä»£ç å¯ä»¥ç±»ä¼¼:

```cpp
std::ostringstream koopa_ir; // ç”¨äºå­˜å‚¨ Koopa IR çš„ stringstream
// ...
ast->print(&koopa_ir);
  // ...
  // inside print(): ä½ çš„ä¸­ç«¯ä»£ç å°† Koopa IR è¾“å‡ºåˆ° koopa_ir ä¸­
  // ...
freopen(output, "w", stdout); // å°† stdout é‡å®šå‘åˆ° output æ–‡ä»¶, output æ˜¯ä½ çš„è¾“å‡ºæ–‡ä»¶è·¯å¾„
backend(koopa_ir.str().c_str()); // å°† stringstream è½¬æ¢ä¸º C style string åäº¤ç»™åç«¯
  // ...
  // inside backend(): åç«¯ä»£ç å°† RISC-V æ±‡ç¼–ä»£ç è¾“å‡ºåˆ° stdout ä¸­
  // ...
fclose(stdout);
```

è¿™æ ·å†™çš„ä¼˜ç‚¹åŒ…æ‹¬: 

- å®ç°ç®€æ´æ˜äº†.
- æ— éœ€è¿›è¡Œç¡¬ç›˜äº¤äº’ (æŠŠ Koopa IR è¾“å‡ºåˆ°æ–‡ä»¶ç³»ç»Ÿå†ä»ç¡¬ç›˜è¯»å–, å†äº¤ç»™åç«¯), è¿™æ ·å®ç°ä¹‹å Koopa IR çš„æ•°æ®ä¿å­˜åœ¨å†…å­˜ä¸­, åç«¯ç›´æ¥ä»å†…å­˜ä¸­è¯»å–å³å¯.

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹:

```bash
autotest -riscv -s lv1 /root/compiler
```

## Lv 3

æœ¬ç« å°†åœ¨ä¸Šä¸€ç« çš„åŸºç¡€ä¸Š, å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¤„ç†è¡¨è¾¾å¼ (ä¸€å…ƒ/äºŒå…ƒ) çš„ç¼–è¯‘å™¨.

éœ€è¦å®Œæˆå¯¹æŠ½è±¡è¯­æ³•æ ‘å’Œ `RISC-V` æ±‡ç¼–ä»£ç è¾“å‡ºè¿™ä¸¤éƒ¨åˆ†çš„ä¿®æ”¹.

ä½ çš„ç¼–è¯‘å™¨å°†å¯ä»¥å¤„ç†å¦‚ä¸‹çš„ SysY ç¨‹åº:

```cpp
int main() 
{
  return 1 + 2 * -3;
}
```

éœ€è¦å®Œæˆå¯¹æŠ½è±¡è¯­æ³•æ ‘å’Œ `RISC-V` æ±‡ç¼–ä»£ç è¾“å‡ºè¿™ä¸¤éƒ¨åˆ†çš„ä¿®æ”¹.

### Lexer

ä¿®æ”¹ `src/sysy.l` æ–‡ä»¶, æ·»åŠ å¯¹è¿ç®—ç¬¦çš„è¯†åˆ«, æ¯”å¦‚ `!` å’Œ `-` è¿ç®—ç¬¦.

```asm
/* è¿ç®—ç¬¦ */
ExclusiveUnaryOp       "!"
MulOp         [\*/%]
AddOp         [\+\-]
RelOp         ("<"|">"|"<="|">=")
EqOp          ("=="|"!=")
AndOp         "&&"
OrOp          "||"
```

è¿™é‡Œæˆ‘çš„é€»è¾‘æ˜¯å¯¹æ¯ä¸€ç§è¿ç®—éƒ½å®šä¹‰ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼, ç”¨æ¥è¡¨è¾¾è¿™ä¸ªè¿ç®—ä¼šä½¿ç”¨çš„æ‰€æœ‰å­—ç¬¦, è¿™æ ·å°±ä¸ç”¨åœ¨è¯­æ³•åˆ†æå™¨ä¸­å¯¹æ¯ä¸€ä¸ªè¿ç®—ç¬¦éƒ½å†™ä¸€ä¸ªè§„çº¦è§„åˆ™äº†. 

ä½†æ˜¯æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯å•å…ƒè¿ç®—ç¬¦å’ŒäºŒå…ƒåŠ å‡è¿ç®—ç¬¦æœ‰ä¸¤ä¸ªç¬¦å·æ˜¯é‡å çš„, æ‰€ä»¥æˆ‘é€‰æ‹©ä½¿ç”¨ `ExclusiveUnaryOp` æ¥è¡¨ç¤ºåªæœ‰å•å…ƒè¿ç®—ç¬¦ä½¿ç”¨çš„ç¬¦å·, `AddOp` å°±ä»£è¡¨ç€å•å…ƒè¿ç®—å’ŒäºŒå…ƒåŠ å‡è¿ç®—å…±åŒä½¿ç”¨çš„ç¬¦å·äº†.

å¦å¤–è¿˜è¦åŠ å…¥è¯†åˆ« token ä¹‹åå¦‚ä½•è¿”å›ç»™è¯­æ³•åˆ†æå™¨, ç±»ä¼¼ `Identifier` å’Œ `Decimal` é‚£æ ·, ä½¿ç”¨ `yylval` æ¥è¿”å›å­—ç¬¦ä¸²ç»™è¯­æ³•åˆ†æå™¨.

```asm
{ExclusiveUnaryOp}      { yylval.str_val = new string(yytext); return EXCLUSIVE_UNARY_OP; }
```

### Parser

ä¿®æ”¹ `src/sysy.y` æ–‡ä»¶å’Œ `include/ast.hpp` æ–‡ä»¶, æ·»åŠ å¯¹æ–°çš„è¯­æ³•è§„åˆ™çš„è§„çº¦.

ä¸¾ä¾‹è¯´æ˜:

```asm
UnaryExp
  : PrimaryExp {
    auto ast = new UnaryExpAST();
    ast->primary_exp = unique_ptr<BaseAST>($1);
    $$ = ast;
  }
  | EXCLUSIVE_UNARY_OP UnaryExp {
    auto ast = new UnaryExpAST();
    ast->op = *unique_ptr<string>($1);
    ast->unary_exp = unique_ptr<BaseAST>($2);
    $$ = ast;
  }
  | ADD_OP UnaryExp {
    auto ast = new UnaryExpAST();
    ast->op = *unique_ptr<string>($1);
    ast->unary_exp = unique_ptr<BaseAST>($2);
    $$ = ast;
  }
  ;
```

å¯¹åº”å¦‚ä¸‹çš„æŠ½è±¡è¯­æ³•æ ‘ç±»:

```cpp
/**
 * @brief ä¸€å…ƒè¡¨è¾¾å¼æŠ½è±¡è¯­æ³•æ ‘ç±». 
 */
class UnaryExpAST : public BaseAST
{
public:
    std::optional<std::unique_ptr<BaseAST>> primary_exp; // å¯é€‰çš„åŸºæœ¬è¡¨è¾¾å¼
    std::optional<std::string> op;                       // å¯é€‰çš„æ“ä½œç¬¦ ("+", "-", "!")
    std::optional<std::unique_ptr<BaseAST>> unary_exp;   // å¯é€‰çš„ä¸€å…ƒè¡¨è¾¾å¼

    /**
     * @brief æ‰“å°æŠ½è±¡è¯­æ³•æ ‘. 
     * @param[in] output_stream è¾“å‡ºæµ. 
     * @return æ‰“å°æ“ä½œçš„ç»“æœ
     */
    Result print(std::stringstream &output_stream) const override; // æ‰“å°æŠ½è±¡è¯­æ³•æ ‘, ç¨åè§£é‡Šè¿™ä¸ªè¿”å›ç±»å‹çš„ç”¨å¤„
};
```

å…¶ä¸­æœ‰ä¸¤ä¸ªå®ç°ç»†èŠ‚:
1. `std::optional` 
   1. æ˜¯ **C++17** å¼•å…¥çš„ç±»å‹, ä½ å¯èƒ½éœ€è¦ä¿®æ”¹ `VSCode` çš„ç¼–è¯‘å™¨ç‰ˆæœ¬, å¦åˆ™æ— æ³•æ­£å¸¸é«˜äº®æ˜¾ç¤º. 
   2. å®ƒç”¨äºè¡¨ç¤ºä¸€ä¸ªå¯èƒ½å­˜åœ¨ä¹Ÿå¯èƒ½ä¸å­˜åœ¨çš„å€¼, å¦‚æœå€¼å­˜åœ¨, åˆ™å¯ä»¥ä½¿ç”¨ `value()` æ–¹æ³•è·å–è¯¥å€¼, å¦‚æœå€¼ä¸å­˜åœ¨, åˆ™å¯ä»¥ä½¿ç”¨ `has_value()` æ–¹æ³•åˆ¤æ–­æ˜¯å¦å­˜åœ¨, æˆ–è€…ä½¿ç”¨ `operator*` è·å–è¯¥å€¼, ç”¨æ¥åˆ¤æ–­åœ¨å¤šä¸ªè§„çº¦è§„åˆ™ä¸­å…·ä½“é€‰äº†é‚£ä¸ªè§„çº¦è§„åˆ™. 
   3. æ¯”å¦‚ä¸‹é¢çš„è§„çº¦è§„åˆ™æœ‰ä¸¤ä¸ªé€‰æ‹©, åˆ†åˆ«æ˜¯ `PrimaryExp` å’Œ `UnaryOp UnaryExp`, å¦‚æœé€‰æ‹©äº† `PrimaryExp` é‚£ä¹ˆ `primary_exp` å°±ä¼šå­˜åœ¨, `op` å’Œ `unary_exp` å°±ä¸å­˜åœ¨, åä¹‹äº¦ç„¶.
2. `print` å‡½æ•°è¿”å›ä¸€ä¸ª `Result` ç±»å‹çš„å˜é‡, ç¨åè§£é‡Šè¿™ä¸ªè¿”å›ç±»å‹çš„ç”¨å¤„.

ä»¥ä¸Šçš„ä»£ç ä»£è¡¨ç€å¦‚ä¸‹çš„è§„çº¦è§„åˆ™:

```asm
UnaryExp    ::= PrimaryExp | UnaryOp UnaryExp;
UnaryOp     ::= "+" | "-" | "!";
```

å…¶ä¸­ä½¿ç”¨äº†æˆ‘ä»¬åœ¨å¯¹è¯æ³•åˆ†æå™¨ä½œä¿®æ”¹çš„æ—¶å€™å®šä¹‰çš„æ–° token ç§ç±» `EXCLUSIVE_UNARY_OP` å’Œ `ADD_OP`.

å½“ç„¶åˆ«å¿˜äº†è¦åœ¨ `src/sysy.y` æ–‡ä»¶ä¸­å®šä¹‰æ–°çš„ç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦çš„ç±»å‹.

```asm
// lexer è¿”å›çš„æ‰€æœ‰ token ç§ç±»çš„å£°æ˜, ç»ˆç»“ç¬¦çš„ç±»å‹ä¸º str_val å’Œ int_val
%token INT RETURN
%token <str_val> IDENT
%token <int_val> INT_CONST
%token <str_val> EXCLUSIVE_UNARY_OP MUL_OP ADD_OP REL_OP EQ_OP AND_OP OR_OP // Operators

// éç»ˆç»“ç¬¦çš„ç±»å‹å®šä¹‰
%type <ast_val> FuncDef FuncType Block Stmt Exp UnaryExp PrimaryExp MulExp AddExp LOrExp LAndExp RelExp EqExp
%type <int_val> Number
```

### `Koopa IR` Generation

ä¿®æ”¹ `ast.cpp` æ–‡ä»¶, æ·»åŠ å¯¹æ–°çš„è¯­æ³•è§„åˆ™çš„ `print` å‡½æ•°.

åœ¨å®ç°ä¹‹å‰æˆ‘ä»¬å…ˆæ¥æ€è€ƒä¸€ä¸ªä¾‹å­:

```cpp
int main() 
{
  return 6;
}
```

è¿™æ˜¯ä¹‹å‰çš„ç¼–è¯‘å™¨å¯ä»¥å¤„ç†çš„ä»£ç , æˆ‘ä»¬åœ¨è°ƒç”¨ `RetAST` çš„ `print` å‡½æ•°æ—¶, å…ˆè¾“å‡º `ret ` ç„¶åè°ƒç”¨ `NumberExpAST` çš„ `print` å‡½æ•°, è¾“å‡º `6`, æœ€åå›åˆ° `RetAST` çš„ `print` å‡½æ•°è¾“å‡º `\n`, å°±å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„ `Koopa IR` ä»£ç :

```asm
fun @main(): i32 {
%entry:
  ret 6
}
```

ç°åœ¨æˆ‘ä»¬è€ƒè™‘è¿™ä¸ªä¾‹å­:

```cpp
int main() 
{
  return -6;
}
```

å¦‚æœè¿˜æ˜¯æŒ‰ç…§ä¹‹å‰çš„é€»è¾‘, å…ˆè¾“å‡º `ret ` ç„¶åè°ƒç”¨ `ExpAST` çš„ `print` å‡½æ•°, å°±ä¼šå‡ºç°é—®é¢˜, å› ä¸ºæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ª `sub` æŒ‡ä»¤æ‰èƒ½è®¡ç®—å‡º `-6`, ä½†æ˜¯æ­¤æ—¶ `Koopa IR` å·²ç»è¾“å‡ºåˆ°æ–‡ä»¶ä¸­äº†, æˆ‘ä»¬æ— æ³•åœ¨ `ret` æŒ‡ä»¤åé¢ç»§ç»­è¾“å‡º `sub` æŒ‡ä»¤äº†.

è¿™æ˜¯æˆ‘ä»¬æœŸæœ›å¾—åˆ°çš„ `Koopa IR` ä»£ç :

```asm
fun @main(): i32 {
%entry:
  %0 = sub 0, 6
  ret %0
}
```

æ‰€ä»¥æˆ‘ä»¬åœ¨è¿›å…¥ä»»ä½•ä¸€ä¸ª `print` å‡½æ•°æ—¶, ä¸èƒ½å…ˆå…¥ä¸ºä¸»åœ°è¾“å‡ºä»»ä½• `Koopa IR` æŒ‡ä»¤, éœ€è¦å…ˆè°ƒç”¨è¿™ä¸ªæŠ½è±¡è¯­æ³•æ ‘çš„æ‰€æœ‰å­å˜é‡çš„ `print` å‡½æ•°, ç­‰åˆ°å®ƒä»¬æŠŠç±»ä¼¼ä¸Šæ–‡çš„ `sub` æŒ‡ä»¤è¾“å‡ºå®Œæˆä¹‹åå†è¾“å‡ºå½“å‰çš„ `Koopa IR` æŒ‡ä»¤.

ä½†æ˜¯å¦‚æœå­å˜é‡çš„æ‰€æœ‰ `print` å‡½æ•°éƒ½æ²¡æœ‰è¿”å›ä»»ä½•ä¿¡æ¯, é‚£ä¹ˆæˆ‘ä»¬æ€ä¹ˆçŸ¥é“è¿™äº›å­å˜é‡æŠŠè®¡ç®—ç»“æœå‚¨å­˜åˆ°å“ªé‡Œäº†å‘¢? 

æ¯”å¦‚ `RetAST` çš„ `print` å‡½æ•°, å½“å®ƒè°ƒç”¨å®Œæˆ `ExpAST` çš„ `print` å‡½æ•°ä¹‹å, å®ƒæ€ä¹ˆçŸ¥é“ `ExpAST` çš„è®¡ç®—ç»“æœæ˜¯å‚¨å­˜åœ¨ `%0` è¿™ä¸ªå¯„å­˜å™¨ä¸­äº†è€Œä¸æ˜¯ `%1` æˆ–è€…å…¶ä»–å¯„å­˜å™¨ä¸­å‘¢? 

æˆ‘ä»¬ä¸å¸Œæœ›ä½¿ç”¨å…¨å±€å˜é‡è§£å†³ä»»ä½•é—®é¢˜, è¿™æ ·éå¸¸ dirty, æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ¯ä¸€ä¸ª `print` å‡½æ•°è¿”å›ä¸€ä¸ª `Result` ç±»å‹çš„å˜é‡, å‘Šè¯‰çˆ¶å˜é‡è¿™ä¸ªå­å˜é‡çš„è®¡ç®—ç»“æœå‚¨å­˜åœ¨å“ªé‡Œ, ä»¥ä¾¿çˆ¶å˜é‡å†³å®šå¦‚ä½•è¾“å‡ºå½“å‰çš„ `Koopa IR` æŒ‡ä»¤.

```cpp
/**
 * @brief ç”¨äºå­˜å‚¨è®¡ç®—ç»“æœçš„ç±», å¯ä»¥æ˜¯ç¬¦å·æˆ–ç«‹å³æ•°. 
 * @note å¦‚æœå½“å‰å‡½æ•°ä¼šäº§ç”Ÿä¸€ä¸ªè®¡ç®—ç»“æœ, é‚£ä¹ˆè¿™ä¸ªè®¡ç®—ç»“æœä¼šå­˜å‚¨åœ¨è¿”å›çš„ `Result` ç±»å‹çš„å˜é‡ä¸­
 * @note æ¯”å¦‚ `PrimaryExpAST` çš„ `print` å‡½æ•°, å½“å®ƒæ˜¯ä»æ•°å­—è§„çº¦è€Œæ¥æ—¶, å®ƒçš„ `Result` å˜é‡ä¼šè¢«åˆå§‹åŒ–ä¸ºç«‹å³æ•°, è¿”å› `Result(Result::Type::IMM, *number)` è¿™æ ·ä¸€ä¸ªå˜é‡
 * @note å¦‚æœå½“å‰å‡½æ•°ä¸ä¼šäº§ç”Ÿè®¡ç®—ç»“æœ, é‚£ä¹ˆè¿”å›çš„ `Result` å˜é‡ä¼šè¢«åˆå§‹åŒ–ä¸ºç«‹å³æ•° 0
 * @date 2024-11-27
 */
class Result
{
public:
    /**
     * @brief å½“å‰è®¡ç®—å€¼, å­˜å‚¨åœ¨ `%current_value_symbol_index` ç¬¦å·ä¸­. 
     * @date 2024-11-27
     */
    static int current_symbol_index;

    enum class Type
    {
        IMM, // ç«‹å³æ•°
        REG  // å¯„å­˜å™¨
    };
    Type type; // ç»“æœçš„ç±»å‹
    int val;   // ç»“æœçš„å€¼

    // é»˜è®¤æ„é€ å‡½æ•°, åˆå§‹åŒ–ä¸ºç«‹å³æ•° 0, æ²¡æœ‰ç”¨åˆ°å®ƒçš„åœ°æ–¹
    Result() : type(Type::IMM), val(0) {}

    // å¸¦æœ‰æŒ‡å®šç±»å‹çš„æ„é€ å‡½æ•°, ä¸»è¦ç”¨æ¥åˆå§‹åŒ–å¯„å­˜å™¨
    Result(Type type) : type(type), val(0)
    {
        if (type == Type::REG)
        {
            val = ++current_symbol_index;
        }
    }

    // å¸¦æœ‰æŒ‡å®šç±»å‹å’Œå€¼çš„æ„é€ å‡½æ•°, ä¸»è¦ç”¨æ¥åˆå§‹åŒ–ç«‹å³æ•°
    Result(Type type, int val) : type(type), val(val)
    {
        if (type == Type::REG)
        {
            val = ++current_symbol_index;
        }
    }

    // é‡è½½ <<
    friend std::ostream &operator<<(std::ostream &os, const Result &result)
    {
        os << (result.type == Result::Type::REG ? "%" : "") << result.val;
        return os;
    }
};
```

`Result` ç±»ä¸­æœ‰ä¸€ä¸ªé™æ€å˜é‡ `current_symbol_index`, è¿™ä¸ªå˜é‡ç”¨äºç»™æ¯ä¸€ä¸ªè®¡ç®—ç»“æœåˆ†é…ä¸€ä¸ªå”¯ä¸€çš„å¯„å­˜å™¨. å½“ `Result` ç±»è¢«åˆå§‹åŒ–ä¸ºç«‹å³æ•°æ—¶, è¿™ä¸ªå˜é‡ä¸ä¼šè¢«ç”¨åˆ°, è€Œå½“ `Result` ç±»è¢«åˆå§‹åŒ–ä¸ºå¯„å­˜å™¨æ—¶, è¿™ä¸ªå˜é‡ä¼šè¢«ç”¨æ¥ç»™è®¡ç®—ç»“æœåˆ†é…ä¸€ä¸ªå”¯ä¸€çš„å¯„å­˜å™¨, ç„¶åè¿™ä¸ª `current_symbol_index` çš„å€¼ä¼šåŠ ä¸€.

åŒæ—¶ä¸ºäº†æ–¹ä¾¿è¾“å‡ºå¯„å­˜å™¨å’Œç«‹å³æ•°, æˆ‘ä»¬é‡è½½äº† `<<` æ“ä½œç¬¦.

```cpp
Result UnaryExpAST::print(std::stringstream &output_stream) const
{
    if (primary_exp && !op && !unary_exp)
    {
        return (*primary_exp)->print(output_stream);
    }
    else if (!primary_exp && op && unary_exp)
    {
        Result unary_result = (*unary_exp)->print(output_stream);
        Result result = Result(Result::Type::REG);
        if (*op == "+")
        {
            output_stream << "\t" << result << " = add 0, " << unary_result << "\n";
        }
        else if (*op == "-")
        {
            output_stream << "\t" << result << " = sub 0, " << unary_result << "\n";
        }
        else if (*op == "!")
        {
            output_stream << "\t" << result << " = eq 0, " << unary_result << "\n";
        }
        else
        {
            throw std::runtime_error("UnaryExpAST::print: invalid unary operator");
        }
        return result;
    }
    else
    {
        throw std::runtime_error("UnaryExpAST::print: invalid unary expression");
    }
}
```

è¿™æ ·çœ‹èµ·æ¥å°±å¾ˆæ¸…æ™°äº†.

1. å½“ `UnaryExpAST` çš„ `print` å‡½æ•°è¢«è°ƒç”¨æ—¶, å¦‚æœå®ƒé€‰æ‹©äº† `UnaryExp ::= PrimaryExp` è¿™æ¡è§„çº¦è§„åˆ™, é‚£ä¹ˆå®ƒå°±ä¼šè°ƒç”¨ `PrimaryExpAST` çš„ `print` å‡½æ•°
2. æ­¤æ—¶ `UnaryExpAST` å¹¶æ²¡æœ‰åšä»»ä½•è®¡ç®—, æ‰€ä»¥ç›´æ¥è¿”å› `PrimaryExpAST` çš„è®¡ç®—ç»“æœå³å¯. 
3. å¦‚æœå®ƒé€‰æ‹©äº† `UnaryExp ::= UnaryOp UnaryExp` è¿™æ¡è§„çº¦è§„åˆ™, å°±éœ€è¦æ ¹æ® `UnaryOp` çš„å€¼è¾“å‡ºç›¸åº”çš„ `Koopa IR` æŒ‡ä»¤, è¿ç®—çš„ç»“æœéœ€è¦ä½¿ç”¨ä¸€ä¸ªæ–°çš„å¯„å­˜å™¨æ¥å‚¨å­˜, æ‰€ä»¥æ„é€ ä¸€ä¸ªæ–°çš„ `Result(Result::Type::REG)` å˜é‡, å¹¶è¿”å›è¿™ä¸ªå˜é‡.
4. æœ€åå¦‚æœå‡ºç°ä»»ä½•ä¾‹å¤–æƒ…å†µ, ç›´æ¥æŠ›å‡ºå¼‚å¸¸, è¿™æ ·æ˜¯å¾ˆå¥½çš„é˜²å¾¡å‹ç¼–ç¨‹æ“ä½œå®è·µ.

### `RISC-V` Assembly Code Generation

åœ¨è¿™ä¸€éƒ¨åˆ†ä½ éœ€è¦ä¿®æ”¹ `include/backend.hpp` å’Œ `src/backend.cpp` æ–‡ä»¶, å®Œæˆæ–°çš„è¯­æ³•è§„åˆ™çš„ `print` å‡½æ•°æ¥è¾“å‡º `RISC-V` æ±‡ç¼–ä»£ç .

è¿™éƒ¨åˆ†çš„éš¾ç‚¹åœ¨äºå¦‚ä½•åˆ†é…å¯„å­˜å™¨, å‚¨å­˜åœ¨å†…å­˜ä¸­çš„ `RISC-V` æ±‡ç¼–ä»£ç æ˜¯æ²¡æœ‰è¿›è¡Œå¯„å­˜å™¨åˆ†é…çš„. 

æ¯”å¦‚ä¸€ä¸ªåŠ æ³•è¿ç®—, ä½ åªçŸ¥é“å·¦æ“ä½œæ•°å’Œå³æ“ä½œæ•°æ˜¯ä¸¤ä¸ªè¡¨è¾¾å¼, ä½†æ˜¯ä½ å¹¶ä¸çŸ¥é“è¿™ä¸¤ä¸ªè¡¨è¾¾å¼çš„ç»“æœåˆ†åˆ«åœ¨å“ªä¸ªå¯„å­˜å™¨å½“ä¸­, å†…å­˜ä¸­çš„æ±‡ç¼–ä»£ç ä¹Ÿä¸æä¾›å…·ä½“çš„å¯„å­˜å™¨ç¼–å·, æ‰€ä»¥ä½ éœ€è¦åœ¨è¾“å‡ºçš„åŒæ—¶ä¸ºæ¯ä¸€è¡Œè¿ç®—éƒ½åˆ†é…ä¸€ä¸ªå¯„å­˜å™¨æ¥ä¿å­˜è¿ç®—çš„ç»“æœ, å¹¶ä¸”ä¸èƒ½è¦†ç›–ä¹‹å‰åˆšè®¡ç®—å®Œè¿˜æ²¡ç”¨è¿‡çš„å¯„å­˜å™¨. 

å¯„å­˜å™¨åˆ†é…é—®é¢˜æ˜¯ä¸€ä¸ª NPC é—®é¢˜, ä½†æ˜¯å¾ˆå¥½çš„ä¸€ç‚¹æ˜¯ Lv3 çš„æµ‹è¯•æ ·ä¾‹ä¸­ä¸ä¼šå‡ºç°éœ€è¦å¯„å­˜å™¨å¤ç”¨çš„æƒ…å†µ, æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜.

é¦–å…ˆä»”ç»†è§‚å¯Ÿä¸€ä¸ªä¾‹å­:

```cpp
int main() 
{
  return 1 + 2 * -3;
}
```

å¯ä»¥å¾—åˆ°å¦‚ä¸‹ `RISC-V` æ±‡ç¼–ä»£ç :

```asm
	.text
	.globl main
main:
  li  t0, 2
  li  t1, 3
  mul t1, t0, t1
  li  t2, 1
  add t2, t1, t2
  mv a0, t2
  ret
```

å¯ä»¥å‘ç°å½“å‰**æ¯ä¸€è¡Œæ±‡ç¼–ä»£ç çš„è®¡ç®—ç»“æœéƒ½åªä¼šè¢«ä½¿ç”¨ä¸€æ¬¡**, å¦‚æœæŠŠè¿™ä¸ªæ±‡ç¼–ä»£ç ä¿®æ”¹ä¸º:

```asm
	.text
	.globl main
main:
  li  t0, 2
  li  t1, 3
  mul t0, t0, t1
  li  t1, 1
  add t0, t0, t1
  mv a0, t0
  ret
```

ä¸ä¼šæœ‰ä»»ä½•é—®é¢˜.

### `RISC-V` Register Manager

ä¸ºäº†æ–¹ä¾¿ç®¡ç†å¯„å­˜å™¨, æˆ‘è®¾è®¡äº†ä¸€ä¸ª `RegisterManager` ç±», è¿™ä¸ªç±»å¯ä»¥è®¾ç½®ä¸€ä¸ªå¯„å­˜å™¨ä¸ºå¯ä»¥è¦†ç›–, åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦å ç”¨äº†ä¸€ä¸ªå¯„å­˜å™¨, ç»™ä¸€ä¸ªå€¼åˆ†é…ä¸€ä¸ªå¯„å­˜å™¨, è¾“å‡ºæŸä¸ªå€¼å¯¹åº”çš„å¯„å­˜å™¨åç§°.

æ‰€æœ‰è®¡ç®—ç»“æœ, åŒ…æ‹¬ä¸€ä¸ªè¡¨è¾¾å¼, ä¸€ä¸ªç«‹å³æ•°, éƒ½æ˜¯è·Ÿä¸€ä¸ª `koopa_raw_value_t` ç±»å‹çš„æŒ‡é’ˆä¸€ä¸€å¯¹åº”çš„, æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `koopa_raw_value_t` ç±»å‹çš„æŒ‡é’ˆæ¥ä½œä¸ºå¯„å­˜å™¨ç®¡ç†å™¨ä¸­çš„é”®å€¼, è¿™æ ·å°±å¯ä»¥æ–¹ä¾¿åœ°æ‰¾åˆ°ä¸€ä¸ªå€¼å¯¹åº”çš„å¯„å­˜å™¨åç§°.

```cpp
/**
 * @brief å¯„å­˜å™¨ç®¡ç†å™¨, å¯ä»¥è®¾ç½®ä¸€ä¸ªå¯„å­˜å™¨ä¸ºå¯ä»¥è¦†ç›–, åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦å ç”¨äº†ä¸€ä¸ªå¯„å­˜å™¨, ç»™ä¸€ä¸ªå€¼åˆ†é…ä¸€ä¸ªå¯„å­˜å™¨, è¾“å‡ºæŸä¸ªå€¼å¯¹åº”çš„å¯„å­˜å™¨åç§°
 */
class RegisterManager
{
private:
    // å€¼åˆ°å¯„å­˜å™¨åç§°çš„æ˜ å°„
    std::unordered_map<koopa_raw_value_t, std::string> _value_to_reg_string;
    // å­˜å‚¨å½“å‰æ‰€æœ‰å¯„å­˜å™¨æ˜¯å¦å¯èƒ½ä¼šå†æ¬¡è¢«åˆ©ç”¨, æ¯”å¦‚å°†ç«‹å³æ•°è½¬ç§»ç»™ a0 å¯„å­˜å™¨, æˆ‘ä»¬ç°åœ¨å°±è®¤ä¸º a0 å¯„å­˜å™¨è¢«å ç”¨äº†, ä½†æ˜¯å¦‚æœ a0 å¯„å­˜å™¨ä¹‹åè¢«è°ƒç”¨äº†, è¿™ä¸ªç«‹å³æ•°è¢«ä½¿ç”¨è¿‡äº†, é‚£ä¹ˆ a0 å¯„å­˜å™¨å°±ä¼šè¢«æ ‡è®°ä¸ºä¸è¢«å ç”¨, å› ä¸ºåˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬è®¤ä¸ºæ¯ä¸€ä¸ªç»“æœåªè¢«ä½¿ç”¨ä¸€æ¬¡
    std::unordered_map<std::string, bool> _reg_is_used;
    /**
     * @brief è®¾ç½®ä¸€ä¸ªå€¼å¯¹åº”å“ªä¸ªå¯„å­˜å™¨, å†…éƒ¨å‡½æ•°ä¸è¢«å¤–éƒ¨è°ƒç”¨
     * @param[in] value å€¼
     * @param[in] reg_string å¯„å­˜å™¨åç§°
     */
    void _set_value_to_reg_string(const koopa_raw_value_t &value, const std::string &reg_string);

public:
    /**
     * @brief æ„é€ å‡½æ•°, åˆå§‹åŒ–æ‰€æœ‰å¯„å­˜å™¨ä¸ºæœªå ç”¨
     */
    RegisterManager()
    {
        // åˆå§‹åŒ–æ‰€æœ‰å¯„å­˜å™¨ä¸ºæœªå ç”¨
        for (int i = 0; i <= 6; ++i)
        {
            _reg_is_used["t" + std::to_string(i)] = false;
        }
        for (int i = 0; i <= 7; ++i)
        {
            _reg_is_used["a" + std::to_string(i)] = false;
        }
    }

    /**
     * @brief è®¾ç½®ä¸€ä¸ªå€¼å¯¹åº”çš„å¯„å­˜å™¨ä¸ºæœªå ç”¨, å½“ä¸€ä¸ªå€¼è¢«ä½¿ç”¨è¿‡ä¹‹å, æˆ‘ä»¬å°†å®ƒå ç”¨çš„å¯„å­˜å™¨è®¾ç½®ä¸ºæœªå ç”¨, å› ä¸ºæˆ‘ä»¬è®¤ä¸ºæ¯ä¸€ä¸ªç»“æœåªè¢«ä½¿ç”¨ä¸€æ¬¡
     * @param[in] value å€¼
     */
    void set_reg_free(const koopa_raw_value_t &value);

    /**
     * @brief åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦å·²ç»åˆ†é…äº†å¯„å­˜å™¨
     * @param[in] value å€¼
     * @return æ˜¯å¦å·²ç»åˆ†é…äº†å¯„å­˜å™¨
     */
    bool exist(const koopa_raw_value_t &value);

    /**
     * @brief ç»™ä¸€ä¸ªå€¼åˆ†é…ä¸€ä¸ªå¯„å­˜å™¨, è‡ªåŠ¨é€‰æ‹©ä¸€ä¸ªæœªè¢«å ç”¨çš„å¯„å­˜å™¨
     * @note x0 æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å¯„å­˜å™¨, å®ƒçš„å€¼æ’ä¸º 0, ä¸”å‘å®ƒå†™å…¥çš„ä»»ä½•æ•°æ®éƒ½ä¼šè¢«ä¸¢å¼ƒ, t0 åˆ° t6 å¯„å­˜å™¨, ä»¥åŠ a0 åˆ° a7 å¯„å­˜å™¨å¯ä»¥ç”¨æ¥å­˜æ”¾ä¸´æ—¶å€¼
     * @param[in] value å€¼
     * @param[in] is_zero å¦‚æœæ˜¯ç«‹å³æ•°, é‚£ä¹ˆæ˜¯å¦æ˜¯ç«‹å³æ•° 0
     */
    void allocate_reg(const koopa_raw_value_t &value, bool is_zero = false);

    /**
     * @brief æ‰¾å‡ºè¿™ä¸ªå€¼å ç”¨å“ªä¸ªå¯„å­˜å™¨, ç”¨äºè¾“å‡º RISC-V æ±‡ç¼–ä»£ç 
     * @param[in] value å€¼
     * @return å¯„å­˜å™¨åç§°
     */
    std::string value_to_reg_string(const koopa_raw_value_t &value);
};
```

### `RISC-V` Assembly Code Output

ä¸ºäº†æ–¹ä¾¿ç»´æŠ¤ `RegisterManager` ç±», æˆ‘é€‰æ‹©å°† `koopa_raw_value_t` ç±»å‹çš„æŒ‡é’ˆä¹Ÿä¼ ç»™ `koopa_raw_integer_t` å’Œ `koopa_raw_binary_t` çš„ `visit` å‡½æ•°, è¿™æ ·åœ¨è¿™ä¸¤ä¸ªå‡½æ•°ä¸­å°±å¯ä»¥è°ƒç”¨ `RegisterManager` ç±»çš„æ–¹æ³•æ¥ç®¡ç†å¯„å­˜å™¨äº†.

```cpp
// è®¿é—® koopa_raw_value_t
void visit(const koopa_raw_value_t &value)
{
    const auto &kind = value->kind;
    switch (kind.tag)
    {
    case KOOPA_RVT_RETURN:
        visit(kind.data.ret);
        break;
    case KOOPA_RVT_INTEGER:
        visit(kind.data.integer, value);
        break;
    case KOOPA_RVT_BINARY:
        visit(kind.data.binary, value);
        break;
    default:
        throw std::runtime_error("visit: invalid instruction");
    }
}

// è®¿é—® return æŒ‡ä»¤
void visit(const koopa_raw_return_t &ret)
{
    // æ ¹æ® ret çš„ value ç±»å‹åˆ¤æ–­åç»­éœ€è¦å¦‚ä½•è®¿é—®
    if (ret.value)
    {
        // ç‰¹åˆ¤å¦‚æœæ˜¯ç«‹å³æ•°, åˆ™ç›´æ¥èµ‹å€¼ç»™ a0 å¯„å­˜å™¨, è·³è¿‡è®¿é—® value çš„è¿‡ç¨‹
        if (ret.value->kind.tag == KOOPA_RVT_INTEGER)
        {
            std::cout << "\tli a0, " << ret.value->kind.data.integer.value << std::endl;
        }
        // å¦åˆ™, è®¿é—®è¿™ä¸ªå€¼, ç„¶åæŠŠè¿™ä¸ªå€¼å­˜å‚¨åœ¨çš„å¯„å­˜å™¨åç§°ç§»åŠ¨ç»™ a0 å¯„å­˜å™¨, æ³¨æ„ä¸æ˜¯ li
        else
        {
            bool is_allocated = register_manager.exist(ret.value);
            if (!is_allocated)
            {
                visit(ret.value);
            }
            std::cout << "\tmv a0, " << register_manager.value_to_reg_string(ret.value) << std::endl;
        }
    }
    // å¦‚æœ ret çš„ value ä¸ºç©º, åˆ™ç›´æ¥èµ‹å€¼ 0 ç»™ a0 å¯„å­˜å™¨, ç„¶åè¿”å›
    else
    {
        std::cout << "\tli a0, 0" << std::endl;
    }
    std::cout << "\tret" << std::endl;
}

// è®¿é—® integer
void visit(const koopa_raw_integer_t &integer, const koopa_raw_value_t &value)
{
    if (integer.value == 0)
    {
        register_manager.allocate_reg(value, true);
    }
    else
    {
        register_manager.allocate_reg(value);
        std::cout << "\tli " << register_manager.value_to_reg_string(value) << ", " << integer.value << std::endl;
    }
}

// è®¿é—® binary æŒ‡ä»¤
void visit(const koopa_raw_binary_t &binary, const koopa_raw_value_t &value)
{
    // lhs å’Œ rhs æ˜¯å¦å·²ç»åˆ†é…è¿‡å¯„å­˜å™¨, å¦‚æœæ²¡åˆ†é…è¿‡, åˆ™éœ€è¦å…ˆè®¿é—® lhs å’Œ rhs, è®¿é—®è¿‡ç¨‹ä¸­ä¼šåˆ†é…å¯„å­˜å™¨, æ³¨æ„ ricsv ä¸èƒ½ç›´æ¥æ“ä½œç«‹å³æ•°, å¿…é¡»å…ˆåŠ è½½åˆ°å¯„å­˜å™¨ä¸­!
    bool lhs_is_allocated = register_manager.exist(binary.lhs);
    if (!lhs_is_allocated)
    {
        visit(binary.lhs);
    }
    bool rhs_is_allocated = register_manager.exist(binary.rhs);
    if (!rhs_is_allocated)
    {
        visit(binary.rhs);
    }
    // æˆ‘ä»¬è®¤ä¸ºæ¯ä¸ªç»“æœä»…ä½¿ç”¨ä¸€æ¬¡, æ‰€ä»¥å¯ä»¥è®¾ç½®ä¸¤ä¸ªå­ç»“æœçš„å¯„å­˜å™¨å¯ä»¥è¢«è¦†ç›–äº†.
    // æ¯”å¦‚å°†ç«‹å³æ•°è½¬ç§»ç»™ a0 å¯„å­˜å™¨, æˆ‘ä»¬ç°åœ¨å°±è®¤ä¸º a0 å¯„å­˜å™¨è¢«å ç”¨äº†, ä½†æ˜¯å¦‚æœ a0 å¯„å­˜å™¨ä¹‹åè¢«è°ƒç”¨äº†, è¿™ä¸ªç«‹å³æ•°è¢«ä½¿ç”¨è¿‡äº†, é‚£ä¹ˆ a0 å¯„å­˜å™¨å°±ä¼šè¢«æ ‡è®°ä¸ºä¸è¢«å ç”¨, å› ä¸ºåˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬è®¤ä¸ºæ¯ä¸€ä¸ªç»“æœåªè¢«ä½¿ç”¨ä¸€æ¬¡
    register_manager.set_reg_free(binary.lhs);
    register_manager.set_reg_free(binary.rhs);
    register_manager.allocate_reg(value);

    // è·å–å½“å‰ç»“æœ, lhs å’Œ rhs å¯¹åº”çš„å¯„å­˜å™¨åç§°
    std::string cur = register_manager.value_to_reg_string(value);
    std::string lhs = register_manager.value_to_reg_string(binary.lhs);
    std::string rhs = register_manager.value_to_reg_string(binary.rhs);

    // æ ¹æ®äºŒå…ƒè¿ç®—ç¬¦çš„ç±»å‹è¿›è¡Œå¤„ç†
    switch (binary.op)
    {
    case KOOPA_RBO_EQ:
        std::cout << "\txor " << cur << ", " << lhs << ", " << rhs << std::endl;
        std::cout << "\tseqz " << cur << ", " << cur << std::endl;
        break;
    case KOOPA_RBO_NOT_EQ:
        std::cout << "\txor " << cur << ", " << lhs << ", " << rhs << std::endl;
        std::cout << "\tsnez " << cur << ", " << cur << std::endl;
        break;
    // ...
    default:
        throw std::runtime_error("visit: invalid binary operator");
    }
}
```

<Aside title='Possible Issues' type='tip'>

å¦‚æœæ— æ³•é€šè¿‡å…¨éƒ¨ Lv3 çš„æµ‹è¯•æ ·ä¾‹, å¯ä»¥æ£€æŸ¥å¦‚ä¸‹å‡ ä¸ªé—®é¢˜:

- æŠŠæ•°æ®ä»å¯„å­˜å™¨ç§»åŠ¨åˆ°å¯„å­˜å™¨æ—¶, ä½¿ç”¨çš„æ˜¯ `mv` æŒ‡ä»¤, è€Œä¸æ˜¯ `li` æŒ‡ä»¤.
- è®¿é—® `return` æŒ‡ä»¤æ—¶, åœ¨è®¿é—® `ret.value` ä¹‹å‰æœ‰æ²¡æœ‰æ£€æŸ¥å®ƒæ˜¯å¦å·²ç»åˆ†é…äº†å¯„å­˜å™¨, å¦åˆ™å¯èƒ½é€ æˆåŒä¸€ä¸ªè¿ç®—è¢«è¾“å‡ºå¤šæ¬¡.
- è¿˜æœ‰ä¸€ä¸ªæµ‹è¯•æ ·ä¾‹, å¯ä»¥æ£€æŸ¥ä½ çš„å¯„å­˜å™¨æ˜¯å¦ä¼šæº¢å‡º:

```cpp
int main() 
{
  return 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0 + 0 * 0;
}
```

</Aside>

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv3 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv3 /root/compiler
```

## Lv 4

æœ¬èŠ‚éœ€è¦è®©ä½ çš„ç¼–è¯‘å™¨å¯ä»¥å¤„ç†å˜é‡çš„å£°æ˜å’Œå®šä¹‰, ç”¨ä¾‹å¦‚ä¸‹:

```cpp
int main() {
  const int x = 233 * 4;
  int y = 10;
  y = y + x / 2;
  return y;
}
```

æ•´ä½“æ¥è®², æœ‰å¦‚ä¸‹å‡ ä¸ªé‡ç‚¹:

1. `koopa` éƒ¨åˆ†éœ€è¦å¢åŠ ç¬¦å·è¡¨æ¥ç®¡ç†å˜é‡.
2. `koopa` éƒ¨åˆ†éœ€è¦å®Œæˆ `const` å˜é‡çš„ç¼–è¯‘æœŸæ±‚å€¼.
3. `riscv` éƒ¨åˆ†åœ¨å¤„ç†ä¸åŒæ¡ `koopa` æŒ‡ä»¤é—´, åªéœ€è¦ç»´æŠ¤æ ˆå¸§.
4. `riscv` éƒ¨åˆ†åœ¨å¤„ç†åŒä¸€æ¡ `koopa` æŒ‡ä»¤æ—¶, éœ€è¦ç»´æŠ¤å¯„å­˜å™¨.

### `Koopa` Symbol Table

å¦‚æœæ˜¯**å¸¸é‡å®šä¹‰**, æ¯”å¦‚ `int x = 233;`, å®ƒä¸éœ€è¦ `koopa` æŒ‡ä»¤æ¥å®Œæˆ.

ä½ åªéœ€è¦åœ¨ç¬¦å·è¡¨ä¸­è®°å½• `@x` è¿™ä¸ªå˜é‡å’Œ `233` è¿™ä¸ªç«‹å³æ•°, å½“å…¶ä»–å‘½ä»¤è°ƒç”¨å˜é‡ `x` æ—¶, æ¯”å¦‚ `y = x;`, ä»ç¬¦å·è¡¨ä¸­æ‰¾åˆ° `@x` è¿™ä¸ªå˜é‡å¯¹åº”çš„æ•°å€¼, ç„¶åç›´æ¥ä½¿ç”¨ `store 233, @y` æŒ‡ä»¤æŠŠ `@x` è¿™ä¸ªå˜é‡çš„å€¼åŠ è½½åˆ°å¯„å­˜å™¨ä¸­ç»™è¿™ä¸ªæŒ‡ä»¤ç”¨.

å¦‚æœæ˜¯**å˜é‡å®šä¹‰**, æ¯”å¦‚ `int y = x + 1;`, å®ƒéœ€è¦è‹¥å¹² `koopa` æŒ‡ä»¤æ¥å®Œæˆ (å‡è®¾ `x` ä¸æ˜¯å¸¸é‡, éœ€è¦ä»å†…å­˜ä¸­åŠ è½½):

```asm
%0 = load @x
add %0, 1
@y = alloc i32
store %0, @y
```

ä½ éœ€è¦åœ¨ç¬¦å·è¡¨ä¸­è®°å½• `@y` è¿™ä¸ªå˜é‡, å½“å…¶ä»–å‘½ä»¤è°ƒç”¨å˜é‡ `y` æ—¶, æ£€æŸ¥ç¬¦å·è¡¨ä¸­æ˜¯å¦æœ‰ `@y` è¿™ä¸ªå˜é‡, å¦‚æœæœ‰, åˆ™ä½¿ç”¨ `%0 = load @y` æŒ‡ä»¤æŠŠ `@y` è¿™ä¸ªå˜é‡çš„å€¼åŠ è½½åˆ°å¯„å­˜å™¨ä¸­ç»™è¿™ä¸ªæŒ‡ä»¤ç”¨.

ç»¼ä¸Šæ‰€è¿°:

ç¬¦å·è¡¨çš„ `key` å°±æ˜¯ `@` å¼€å¤´çš„å†…å­˜å, `value` æ˜¯ `i32` ç±»å‹çš„ç«‹å³æ•° (å¸¸é‡å®šä¹‰) æˆ–ä»€ä¹ˆéƒ½æ²¡æœ‰ (å˜é‡å®šä¹‰, ä½†æ˜¯å¦‚æœä½ æƒ³ä¿æŒä¸€è‡´æ€§ä¹Ÿå¯ä»¥æŠŠ `%` å¼€å¤´çš„å¯„å­˜å™¨åå­˜ä¸‹æ¥, åœ¨ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­æ˜¯ `%0` ; ä¸è¿‡åœ¨å¤šå±‚åµŒå¥—çš„å—ä¸­, æˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªå˜é‡å¤„åœ¨çš„å®šä¹‰åŸŸçš„å±‚çº§ç”¨ `value` æ¥ä¼ é€’, å…·ä½“å¯ä»¥å‚è€ƒ Lv5 çš„å®ç°).

ç¬¦å·å’Œç¬¦å·è¡¨

```cpp
/**
 * @brief ç¬¦å·
 * @date 2024-12-22
 */
class Symbol
{
public:
    enum class Type
    {
        VAR,
        VAL
    };
    Type type;
    int val;
    Symbol() : type(Type::VAL), val(0) {}
    Symbol(Type type, int val) : type(type), val(val) {}
};

/**
 * @brief ç¬¦å·è¡¨
 * @date 2024-12-22
 */
class SymbolTable
{
private:
    std::unordered_map<std::string, Symbol> symbol_table;
    bool is_returned = false;

public:
    void create(const std::string &name, Symbol symbol);
    bool exist(const std::string &name);
};
```

åœ¨å¸¸é‡çš„å®šä¹‰ä¸­ç»´æŠ¤ç¬¦å·è¡¨:

```cpp
Result ConstDefAST::print(std::stringstream &output_stream) const
{
    if (symbol_table.exist(const_symbol)) // å¦‚æœç¬¦å·è¡¨ä¸­å·²ç»å­˜åœ¨è¿™ä¸ªç¬¦å·, åˆ™æŠ›å‡ºé”™è¯¯
    {
        throw std::runtime_error("ConstDefAST::print: const identifier already exists");
    }
    Result value_result = const_init_val->print(output_stream); // è®¡ç®—å¸¸é‡è¡¨è¾¾å¼çš„å€¼
    symbol_table.create(const_symbol, Symbol(Symbol::Type::VAL, value_result.val)); // å°†å¸¸é‡è¡¨è¾¾å¼çš„å€¼å­˜å…¥ç¬¦å·è¡¨
    return Result(); // è¿”å›ç©ºç»“æœ, ä¸ºä»€ä¹ˆä¸è¿”å›è°ƒç”¨ print çš„è¿”å›å€¼? å› ä¸ºæˆ‘ä»¬çš„å…ˆéªŒçŸ¥è¯† (è¯­ä¹‰è§„èŒƒ) å‘Šè¯‰æˆ‘ä»¬, å£°æ˜å’Œå®šä¹‰è¯­å¥ä¸ä¼šè¿”å›ä»»ä½•å€¼
}
```

### `Koopa` Const Variable Compile-time Computation

```cpp
int main() {
  const int x = 1 + 1;
  return x;
}
```

è¿™æ ·ä¸€ä¸ªè¿”å›å¸¸é‡çš„ä»£ç , æˆ‘ä»¬ç›´æ¥è¿”å› `2` å³å¯:

```asm
fun @main(): i32 {
%entry:
  ret 2
}
```

å¯ä»¥çœ‹åˆ° `1 + 1` åœ¨ç¼–è¯‘æœŸå°±è¢«æ±‚å€¼ä¸º `2` äº†, é‚£ä¹ˆå¦‚ä½•å®Œæˆ `const` å˜é‡çš„ç¼–è¯‘æœŸæ±‚å€¼å‘¢? 

æˆ‘ä»¬åªéœ€è¦åœ¨è®¿é—®æ¯ä¸€ä¸ªè®¡ç®—èŠ‚ç‚¹, æ¯”å¦‚ `AddExpAST::print` çš„æ—¶å€™åˆ¤æ–­å®ƒçš„å·¦å³æ“ä½œæ•°æ˜¯ä¸æ˜¯éƒ½æ˜¯ç«‹å³æ•°, å¦‚æœæ˜¯ç«‹å³æ•°å°±è¿”å›è®¡ç®—å®Œçš„ç«‹å³æ•°, å¦‚æœä¸æ˜¯ç«‹å³æ•°æ‰éœ€è¦ `%1 = add %0, 1` è¿™æ ·çš„è®¡ç®—æŒ‡ä»¤.

```cpp
Result AddExpAST::print(std::stringstream &output_stream) const
{
    if (!add_exp && !op && mul_exp)
    {
        return (*mul_exp)->print(output_stream);
    }
    else if (add_exp && op && mul_exp)
    {
        Result result_left = (*add_exp)->print(output_stream);
        Result result_right = (*mul_exp)->print(output_stream);
        if (result_left.type == Result::Type::IMM && result_right.type == Result::Type::IMM)
        {
            if (*op == "+")
            {
                return Result(Result::Type::IMM, result_left.val + result_right.val);
            }
            else if (*op == "-")
            {
                return Result(Result::Type::IMM, result_left.val - result_right.val);
            }
            else
            {
                throw std::runtime_error("AddExpAST::print: invalid add operator when both operands are immediate");
            }
        }
        else
        {
            Result result = Result(Result::Type::REG);
            if (*op == "+")
            {
                output_stream << "\t" << result << " = add " << result_left << ", " << result_right << "\n";
            }
            else if (*op == "-")
            {
                output_stream << "\t" << result << " = sub " << result_left << ", " << result_right << "\n";
            }
            else
            {
                throw std::runtime_error("AddExpAST::print: invalid add operator when one of the operands is not immediate");
            }
            return result;
        }
    }
    else
    {
        throw std::runtime_error("AddExpAST::print: invalid add expression");
    }
}
```

å¯ä»¥çœ‹å‡º, å¦‚æœ `AddExpAST::print` çš„å·¦å³æ“ä½œæ•°éƒ½æ˜¯ç«‹å³æ•°, é‚£ä¹ˆ `AddExpAST::print` çš„è¿”å›å€¼å°±æ˜¯ç«‹å³æ•°, å¦åˆ™å°±æ˜¯å¯„å­˜å™¨.

è¿™æ ·æˆ‘ä»¬é¿å…äº†å·²ç»çŸ¥é“å·¦å³æ“ä½œæ•°çš„çœŸå®æ•°å€¼çš„æƒ…å†µä¸‹ä¾ç„¶ç”Ÿæˆ `add` æŒ‡ä»¤, ä»è€Œå®ç°äº†ç¼–è¯‘æœŸæ±‚å€¼, åŒæ—¶è¿™æ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹, æ‰€ä»¥ä»…éœ€è¦ä¿®æ”¹å¾ˆå°‘çš„ä»£ç å°±å¯ä»¥å®ç°.

### `RISC-V` Stack Frame

åœ¨å¤„ç†ä¸åŒæ¡ `koopa` æŒ‡ä»¤é—´åªéœ€è¦ç»´æŠ¤æ ˆå¸§è€Œä¸éœ€è¦ç»´æŠ¤å¯„å­˜å™¨, å…·ä½“æ¥è®², åœ¨ä½¿ç”¨åˆ° `@x` æˆ– `%1` ç­‰**æ‰€æœ‰** `koopa` å˜é‡å’Œå†…å­˜æ—¶ç»´æŠ¤æ ˆå¸§.

`@x` å­˜åœ¨æ ˆå¸§ä¸Šæ˜¯æ²¡æœ‰é—®é¢˜çš„, æ¯•ç«Ÿ `koopa` å°±æ˜¯è¿™ä¹ˆåšçš„.

ä½†æ˜¯ `%1` è¿™æ ·çš„ `koopa` å¯„å­˜å™¨åº”è¯¥å­˜åœ¨å“ªé‡Œå‘¢? æˆ‘ä»¬ä¸ºäº†ç®€åŒ–å¯„å­˜å™¨åˆ†é…, å› æ­¤å°† `koopa` çš„æ‰€æœ‰å¯„å­˜å™¨è®¡ç®—å‡ºæ¥ä¹‹å, ä¹Ÿå­˜åœ¨ `riscv` çš„æ ˆå¸§ä¸Š, å¦‚æœè¿™ä¸ª `%1` ä¹‹åè¢«ä½¿ç”¨äº†, å°±ä»æ ˆå¸§ä¸­æ‰¾åˆ° `%1` å¯¹åº”çš„å†…å­˜å³å¯.

å¯ä»¥çœ‹ä¸‹é¢çš„ä¾‹å­, `%2 = load @y` è®¡ç®—å‡ºæ¥äº† `%2` çš„å€¼, æˆ‘ä»¬çš„æ“ä½œæ˜¯æŠŠå®ƒå­˜åœ¨äº† `sp + 12` è¿™ä¸ªä½ç½®, ç„¶å `ret %2` çš„æ—¶å€™ä» `sp + 12` è¿™ä¸ªä½ç½®å–å‡º `%2` çš„å€¼, ä»è€Œåœ¨ä¸åŒ `koopa` æŒ‡ä»¤é—´é€šè¿‡æ ˆå¸§ä¼ é€’ä¿¡æ¯, å®Œå…¨ä¸ä½¿ç”¨å¯„å­˜å™¨.

```asm
	.text
	.globl main
main:
	addi sp, sp, -16

  # store 10, @y
	li t0, 10
	sw t0, 0(sp)

  # %0 = load @y
	lw t0, 0(sp)
	sw t0, 4(sp) 

  # %1 = add %0, 466
	lw t0, 4(sp)
	li t1, 466
	add t0, t0, t1
	sw t0, 8(sp)

  # store %1, @y
	lw t0, 8(sp)
	sw t0, 0(sp)

  # %2 = load @y
	lw t0, 0(sp)
	sw t0, 12(sp)

  # ret %2
	lw a0, 12(sp)
	addi sp, sp, 16
    ret
```

æˆ‘ä½¿ç”¨äº† `ContextManager` æ¥ç®¡ç†æ ˆå¸§å’Œå¯„å­˜å™¨, è¿™æ˜¯ä» `Lv3` çš„ `RegisterManager` åŠ å…¥äº†æ ˆå¸§çš„ç®¡ç†å™¨å¾—åˆ°çš„.

æ‰€æœ‰ä»£ç å…±ç”¨ä¸€ä¸ª `ContextManager`, æ¯ä¸€ä¸ªå‡½æ•°åœ¨è¿›å…¥çš„æ—¶å€™å•å¼€ä¸€ä¸ª `StackManager`.

å…·ä½“æ¥è®²:

```cpp
/**
 * @brief å¯„å­˜å™¨å’Œæ‰€æœ‰å‡½æ•°çš„æ ˆç®¡ç†å™¨, æ˜¯å…¨å±€å…±ç”¨çš„, å¯ä»¥ç»´æŠ¤å€¼å’Œå¯„å­˜å™¨çš„å…³ç³», å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå€¼å’Œè¿™ä¸ªå€¼å¯¹åº”çš„å‡½æ•°çš„æ ˆä¿¡æ¯
 * @author Yutong Liang
 * @date 2024-11-28
 */
class ContextManager
{
private:
    // å€¼åˆ°å¯„å­˜å™¨åç§°çš„æ˜ å°„
    std::unordered_map<koopa_raw_value_t, std::string> _value_to_reg_string;

    // å­˜å‚¨å½“å‰æ‰€æœ‰å¯„å­˜å™¨æ˜¯å¦æœ‰ä¸èƒ½è¢«è¦†ç›–çš„å€¼
    std::unordered_map<std::string, bool> _reg_is_used;

    /**
     * @brief è®¾ç½®ä¸€ä¸ªå€¼å¯¹åº”å“ªä¸ªå¯„å­˜å™¨, å†…éƒ¨å‡½æ•°ä¸è¢«å¤–éƒ¨è°ƒç”¨
     * @param[in] value å€¼
     * @param[in] reg_string å¯„å­˜å™¨åç§°
     * @author Yutong Liang
     * @date 2024-11-28
     */
    void _set_value_to_reg_string(const koopa_raw_value_t &value, const std::string &reg_string);

    // å‡½æ•°ååˆ°è¿™ä¸ªå‡½æ•°çš„ StackManager çš„æ˜ å°„
    std::unordered_map<std::string, StackManager> _function_name_to_stack_manager;

    // å½“å‰æ­£åœ¨å¤„ç†çš„å‡½æ•°çš„å‡½æ•°å
    std::string current_function_name;
};

/**
 * @brief å•ä¸ªå‡½æ•°çš„æ ˆç®¡ç†å™¨, æ˜¯ä¸€ä¸ªå‡½æ•°ä½¿ç”¨çš„, å¯ä»¥ç»´æŠ¤å€¼ (æ¯”å¦‚ `@x`, `%1`) å’Œæ ˆåœ°å€çš„å…³ç³»
 * @author Yutong Liang
 * @date 2024-12-22
 */
class StackManager
{
private:
    // æ ˆå¸§å¤§å°, åˆå§‹åŒ–çš„æ—¶å€™ç¡®å®šçš„, å•ä½æ˜¯å­—èŠ‚
    int stack_size;

    // æ ˆå¸§å½“å‰ä½¿ç”¨æƒ…å†µ, åˆå§‹åŒ–æ—¶0, ç›´åˆ°å¢é•¿ä¸º stack_size ä¸ºæ­¢, å•ä½æ˜¯å­—èŠ‚
    int stack_used_byte;

    // å€¼åˆ°æ ˆåœ°å€çš„æ˜ å°„, æ ˆåœ°å€çš„è¡¨ç¤ºæ–¹æ³•æ˜¯ "sp + offset" ä¸­çš„ int offset
    std::unordered_map<koopa_raw_value_t, int> value_to_stack_offset;
};
```

### `RISC-V` Register Allocation

<Aside title='å¯„å­˜å™¨åˆ†é…åŸåˆ™' type='note'>

ä¸åŒ `koopa` ä»£ç ä¹‹é—´å…±äº«æ ˆå¸§ä½†æ˜¯å¯„å­˜å™¨ä¸äº’ç›¸å½±å“, åŒä¸€è¡Œ `koopa` ä»£ç ä¹‹é—´æ‰å¯èƒ½äº§ç”Ÿå¯„å­˜å™¨çš„å½±å“, æ¯ä¸€æ¡ `koopa` æŒ‡ä»¤ä½¿ç”¨è‡ªå·±çš„å¯„å­˜å™¨ç„¶åé‡Šæ”¾è‡ªå·±çš„å¯„å­˜å™¨.

è¿™æ˜¯å› ä¸ºæ¯ä¸€è¡Œ `koopa` ä»£ç åªä¼šä½¿ç”¨ `@x`, `%1`, `1` è¿™æ ·çš„å€¼, è€Œè¿™äº›å€¼åœ¨ RISC-V ä¸­è¦ä¹ˆåœ¨å†…å­˜ä¸­, è¦ä¹ˆå°±æ˜¯ç«‹å³æ•°, æ‰€ä»¥**ä»»æ„ä¸¤ä¸ª `koopa` æŒ‡ä»¤ä¹‹é—´æ˜¯ä¸ä¼šäº§ç”Ÿå¯„å­˜å™¨å¤ç”¨çš„**.

</Aside>

æœ‰äº†è¿™ä¸ªåŸåˆ™, æˆ‘ä»¬åœ¨å®ç°çš„æ—¶å€™å°±å¯ä»¥å®‰å¿ƒåœ°ä½¿ç”¨å¯„å­˜å™¨äº†.

åœ¨è®¿é—® `koopa_raw_value_t` çš„æ—¶å€™, åªè®¿é—®å¯¹åº” `koopa` æŒ‡ä»¤çš„æŠ½è±¡è¯­æ³•æ ‘, ä¸å¯¹åº”çš„ä¸è®¿é—®, æ¯”å¦‚ç«‹å³æ•°å°±ä¸è¦è®¿é—®, å› ä¸ºè¿™æ ·å®‰æ’é€»è¾‘æ¸…æ™°, ä¿è¯äº†å¯„å­˜å™¨ä½¿ç”¨çš„è§£è€¦, ä¸¤ä¸ª `visit` å‡½æ•°ä¹‹é—´æ²¡æœ‰å¯„å­˜å™¨ä¾èµ–å…³ç³», åŒæ—¶ `switch` ä¸­æ¯ä¸€ä¸ª `visit` å‡½æ•°éƒ½ä¼šä½¿ç”¨åé‡Šæ”¾è‡ªå·±çš„å¯„å­˜å™¨.

```cpp
// è®¿é—®æŒ‡ä»¤
void visit(const koopa_raw_value_t &value)
{
    const auto &kind = value->kind;
    switch (kind.tag)
    {
    case KOOPA_RVT_RETURN:
        // è®¿é—® return æŒ‡ä»¤
        visit(kind.data.ret);
        break;
    case KOOPA_RVT_BINARY:
        // è®¿é—® binary è®¡ç®—æŒ‡ä»¤
        visit(kind.data.binary, value);
        break;
    case KOOPA_RVT_ALLOC:
        // è®¿é—® alloc æŒ‡ä»¤, åˆ†é…å†…å­˜æ˜¯å®é™…å­˜åœ¨çš„æŒ‡ä»¤, ä½†æ˜¯æ±‡ç¼–è¯­è¨€çš„å†…å­˜åˆ†é…æ˜¯ç›´æ¥ç”¨æ ˆæŒ‡é’ˆç®¡ç†çš„, æ‰€ä»¥ä¸éœ€è¦æ˜¾å¼çš„å†…å­˜åˆ†é…, å¯ä»¥å¿½ç•¥ koopa çš„ alloc æŒ‡ä»¤
        // æ¯”å¦‚ @x = alloc i32 è¿™æ ·ä¸€ä¸ªæŒ‡ä»¤, å¦‚æœåªæœ‰è¿™ä¸ªæŒ‡ä»¤æœ¬èº«, å¹¶ä¸éœ€è¦åšä»»ä½•æ“ä½œä¹Ÿèƒ½ä¿è¯ RISC-V çš„æ­£ç¡®æ€§
        // åªæœ‰åœ¨ä½¿ç”¨äº† @x çš„æ—¶å€™, æ¯”å¦‚ store 10, @x è¿™æ ·çš„æŒ‡ä»¤, æ‰éœ€è¦è®¾å®š @x çš„æ ˆåœ°å€, æ‰€ä»¥ alloc æŒ‡ä»¤å¯ä»¥å¿½ç•¥
        break;
    case KOOPA_RVT_LOAD:
        // è®¿é—® load æŒ‡ä»¤
        visit(kind.data.load, value);
        break;
    case KOOPA_RVT_STORE:
        // è®¿é—® store æŒ‡ä»¤
        visit(kind.data.store, value);
        break;
    default:
        // å…¶ä»–ç±»å‹æš‚æ—¶é‡ä¸åˆ°
        throw std::runtime_error("visit: invalid instruction");
    }
}
```

æ¯”å¦‚ `%1 = add %0, 1` è¿™æ ·çš„æŒ‡ä»¤, åªè®¿é—® `add` æŒ‡ä»¤, åœ¨è®¿é—® `add` çš„æ—¶å€™ä¸è°ƒç”¨ `visit( ç«‹å³æ•° 1 )` , å‚è€ƒå¦‚ä¸‹ 7-17 è¡Œä»£ç , è€Œæ˜¯ç›´æ¥å°† `1` åŠ è½½åˆ°å¯„å­˜å™¨ä¸­, å› ä¸ºç«‹å³æ•°ä¸æ˜¯ `koopa` æŒ‡ä»¤, å¦‚æœè®¿é—®äº†å°±è¿åäº†æˆ‘ä»¬æœ€å¼€å§‹çš„åŸåˆ™äº†.

```cpp
// è®¿é—® binary æŒ‡ä»¤
void visit(const koopa_raw_binary_t &binary, const koopa_raw_value_t &value)
{
    // åˆ¤æ–­ lhs æ˜¯ç«‹å³æ•°è¿˜æ˜¯å†…å­˜, å¦‚æœæ˜¯ç«‹å³æ•°å°± li, å¦åˆ™å°± lw
    context_manager.allocate_reg(binary.lhs);
    std::string lhs = context_manager.value_to_reg_string(binary.lhs);
    if (binary.lhs->kind.tag == KOOPA_RVT_INTEGER) // è¿™é‡Œä¸è¦è°ƒç”¨ visit( ç«‹å³æ•° 1 ), å› ä¸ºè¿™ä¸æ˜¯ä¸€ä¸ª koopa æŒ‡ä»¤
    {
        riscv_printer.li(lhs, binary.lhs->kind.data.integer.value);
    }
    else
    {
        // å½“å‰å‡½æ•°çš„ StackManager
        StackManager &stack_manager = context_manager.get_current_function_stack_manager();
        // ä»æ ˆä¸­åŠ è½½æ•°æ®åˆ°å¯„å­˜å™¨
        riscv_printer.lw(lhs, "sp", stack_manager.get_value_stack_offset(binary.lhs), context_manager);
    }
    // åˆ¤æ–­ rhs æ˜¯ç«‹å³æ•°è¿˜æ˜¯å†…å­˜, å¦‚æœæ˜¯ç«‹å³æ•°å°± li, å¦åˆ™å°± lw
    context_manager.allocate_reg(binary.rhs);
    std::string rhs = context_manager.value_to_reg_string(binary.rhs);
    if (binary.rhs->kind.tag == KOOPA_RVT_INTEGER)
    {
        riscv_printer.li(rhs, binary.rhs->kind.data.integer.value);
    }
    else
    {
        // å½“å‰å‡½æ•°çš„ StackManager
        StackManager &stack_manager = context_manager.get_current_function_stack_manager();
        // ä»æ ˆä¸­åŠ è½½æ•°æ®åˆ°å¯„å­˜å™¨
        riscv_printer.lw(rhs, "sp", stack_manager.get_value_stack_offset(binary.rhs), context_manager);
    }

    // ç»™ç»“æœåˆ†é…ä¸€ä¸ªå¯„å­˜å™¨, åˆ†é…ä¹‹å‰å¯ä»¥å…ˆé‡Šæ”¾æ‰ lhs å’Œ rhs å¯¹åº”çš„å¯„å­˜å™¨, å› ä¸ºä»–ä»¬ç›¸å½“äºå·²ç»åŠ è½½è¿›æ¥äº†, ä¸€ä¼šä½¿ç”¨çš„æ—¶å€™å¯ä»¥è¦†ç›–, æ¯”å¦‚ add t0, t0, t1
    context_manager.set_reg_free(binary.lhs);
    context_manager.set_reg_free(binary.rhs);
    context_manager.allocate_reg(value);
    std::string cur = context_manager.value_to_reg_string(value);

    // æ ¹æ®äºŒå…ƒè¿ç®—ç¬¦çš„ç±»å‹è¿›è¡Œå¤„ç†
    switch (binary.op)
    {
    case KOOPA_RBO_EQ:
        riscv_printer.xor_(cur, lhs, rhs);
        riscv_printer.seqz(cur, cur);
        break;
    // ...
    default:
        throw std::runtime_error("visit: invalid binary operator");
    }
    // å½“å‰å‡½æ•°çš„ StackManager
    StackManager &stack_manager = context_manager.get_current_function_stack_manager();
    // æŠŠç»“æœå­˜å›æ ˆä¸­
    stack_manager.save_value_to_stack(value);
    riscv_printer.sw(cur, "sp", stack_manager.get_value_stack_offset(value), context_manager);
    // å½“å‰ç»“æœæ‰€åœ¨çš„å¯„å­˜å™¨å·²ç»è¢«ä½¿ç”¨è¿‡äº†, é‡Šæ”¾
    context_manager.set_reg_free(value);
}
```

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv4 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv4 /root/compiler
```

## Lv5

è¿™æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„ Level å‘€, åªéœ€è¦åœ¨ Lv4 çš„åŸºç¡€ä¸Šå°†ä¸€ä¸ª `SymbolTable` å˜ä¸ºå¤šä¸ªå°±å¯ä»¥äº†.

### Multiple Symbol Table

Lv4 ä¸­çš„ `SymbolTable` :

```cpp
class SymbolTable
{
private:
    std::unordered_map<std::string, Symbol> symbol_table;
    bool is_returned = false;

public:
    // CRUD ...
};
```

Lv5 ä¸­çš„ `SymbolTable` :

```cpp
class SymbolTable
{
private:
    std::vector<std::unordered_map<std::string, Symbol>> symbol_table; // æ¯è¿›å…¥ä¸€ä¸ªå—, å°±åˆ›å»ºä¸€ä¸ªæ–°çš„ç¬¦å·è¡¨, å—åŒ…æ‹¬å‡½æ•°çš„å¤§æ‹¬å·å’Œè¯­å¥å—çš„å¤§æ‹¬å·
    bool is_returned = false;

public:
    // æ¯è¿›å…¥ä¸€ä¸ªå—, å°±åˆ›å»ºä¸€ä¸ªæ–°çš„ç¬¦å·è¡¨, å—åŒ…æ‹¬å‡½æ•°çš„å¤§æ‹¬å·å’Œè¯­å¥å—çš„å¤§æ‹¬å·
    void new_symbol_table_hierarchy();
    // æ¯ç¦»å¼€ä¸€ä¸ªå—, å°±åˆ é™¤ä¸€ä¸ªç¬¦å·è¡¨
    void delete_symbol_table_hierarchy();
    // CRUD ...
};
```

åŒºåˆ«åœ¨äºæˆ‘ä»¬æŠŠ `SymbolTable` ä»å•ä¸ªå˜ä¸ºå¤šä¸ª, æ„å»ºä¸ºä¸€ä¸ªæ ˆ, æ¯è¿›å…¥ä¸€ä¸ªå—, å°±åˆ›å»ºä¸€ä¸ªæ–°çš„ç¬¦å·è¡¨, æ¯ç¦»å¼€ä¸€ä¸ªå—, å°±åˆ é™¤ä¸€ä¸ªç¬¦å·è¡¨.

åŒæ—¶æˆ‘ä»¬éœ€è¦ä¿®æ”¹å†…å­˜çš„å­˜å‚¨ä½ç½®, å› ä¸ºä¸åŒå±‚çš„å®šä¹‰åŸŸå¯èƒ½ä½¿ç”¨åŒä¸€ä¸ªå˜é‡å (ä¾‹å­å¦‚ä¸‹), æ­¤æ—¶åº”è¯¥ä»å†…å‘å¤–æ‰¾åˆ°æœ€è¿‘çš„å˜é‡åç„¶åä½¿ç”¨è¿™ä¸€å±‚çš„å†…å­˜åœ°å€.

```asm
fun @main(): i32 {
%entry:
  @a_1 = alloc i32
  store 1, @a_1
  store 2, @a_1
  @a_2 = alloc i32
  store 3, @a_2
  %0 = load @a_1
  ret %0
}
```

### Naming Same Symbol From Different Scope

é‚£ä¹ˆå…·ä½“åº”è¯¥å¦‚ä½•å‘½åå‘¢? æˆ‘ä»¬æ°å·§å¯ä»¥ä½¿ç”¨è¿™ä¸ªå˜é‡å¤„äºçš„ `vector` çš„ `index` æ¥å‘½å, æ¯”å¦‚ç¬¬ä¸€ä¸ª `@a` å¤„äº `symbol_table[0]` ä¸­, é‚£ä¹ˆæˆ‘ä»¬å°±æŠŠè®¿é—®ç¬¬ä¸€å±‚ä¸­çš„ `@a` çš„å†…å­˜åœ°å€è¡¨ç¤ºä¸º `@a_1`, ç¬¬äºŒä¸ª `@a` å¤„äº `symbol_table[1]` ä¸­, é‚£ä¹ˆæˆ‘ä»¬å°±æŠŠè®¿é—®ç¬¬äºŒå±‚ä¸­çš„ `@a` çš„å†…å­˜åœ°å€è¡¨ç¤ºä¸º `@a_2`.

å…·ä½“å®ç°å¯ä»¥å‚è€ƒ:

```cpp
class Symbol
{
public:
    enum class Type
    {
        VAR,
        VAL
    };
    Type type;
    int val; // å¦‚æœ type æ˜¯ VAL, é‚£ä¹ˆ val æ˜¯ç«‹å³æ•°çš„æ•°å€¼; å¦‚æœ type æ˜¯ VAR, é‚£ä¹ˆ val æ˜¯å˜é‡çš„å±‚çº§, æ¯”å¦‚ `a = 2;` å¦‚æœåœ¨ç¬¦å·è¡¨ä¸­åœ¨å±‚çº§ 1 æ‰¾åˆ°è¿™ä¸ªç¬¦å·, é‚£ä¹ˆå°±ä¼šè¿”å› 1, å¾—åˆ° @a_1
    Symbol() : type(Type::VAL), val(0) {}
    Symbol(Type type, int val) : type(type), val(val) {}
};

Symbol SymbolTable::read(const std::string &name)
{
    for (int i = symbol_table.size() - 1; i >= 0; --i)
    {
        if (symbol_table[i].find(name) != symbol_table[i].end())
        {
            Symbol symbol = symbol_table[i].at(name);
            if (symbol.type == Symbol::Type::VAL)
            {
                return symbol; // å¦‚æœæ˜¯å¸¸é‡, ç›´æ¥è¿”å›å¸¸é‡çš„å€¼
            }
            else if (symbol.type == Symbol::Type::VAR)
            {
                return Symbol(Symbol::Type::VAR, i + 1); // å¦‚æœæ˜¯å˜é‡, è¿”å›å˜é‡æ‰€åœ¨çš„ SymbolTable çš„ index
            }
            else
            {
                throw std::runtime_error("SymbolTable::read: invalid symbol type");
            }
        }
    }
    throw std::runtime_error("SymbolTable::read: identifier does not exist");
}
```

å¦‚æœæ˜¯ `Symbol::Type::VAR` , æˆ‘ä»¬å¯ä»¥æ­£å¥½ä½¿ç”¨ `Symbol::val` æ¥è¡¨ç¤ºå®ƒå¤„äºçš„ `symbol_table` çš„ `index` , æ¯•ç«Ÿè¿™ä¸ª `Symbol` åˆå§‹åŒ–çš„æ—¶å€™ `Symbol::val` å°±æ˜¯æ²¡ç”¨çš„, å¯ä»¥å‚è€ƒå¦‚ä¸‹çš„åˆå§‹åŒ–ä»£ç å’Œå®ƒçš„ Context:

```cpp
Result VarDefAST::print(std::stringstream &output_stream) const
{
    if (var_init_val)
    {
        Result value_result = (*var_init_val)->print(output_stream);
        symbol_table.insert_symbol(var_symbol, Symbol(Symbol::Type::VAR, value_result.val));
        std::string symbol_name = var_symbol;
        std::string suffix = std::to_string(symbol_table.read(symbol_name).val);
        std::string symbol_name_with_suffix = symbol_name + "_" + suffix;
        output_stream << "\t@" << symbol_name_with_suffix << " = alloc i32\n";
        output_stream << "\tstore " << value_result << ", @" << symbol_name_with_suffix << "\n";
    }
    else
    {
        symbol_table.insert_symbol(var_symbol, Symbol(Symbol::Type::VAR, 0));
        std::string symbol_name = var_symbol;
        std::string suffix = std::to_string(symbol_table.read(symbol_name).val);
        std::string symbol_name_with_suffix = symbol_name + "_" + suffix;
        output_stream << "\t@" << symbol_name_with_suffix << " = alloc i32\n";
    }
    return Result();
}
```

å…¶ä¸­ç¬¬å…­è¡Œä¸­ç”¨ `value_result.val` åˆå§‹åŒ–äº†è¿™ä¸ª `Symbol` , ä½†æ˜¯å®é™…ä¸Šè¿™ä¸ªå€¼æ˜¯ `koopa` å¯„å­˜å™¨çš„åç§°, æˆ‘ä»¬å¹¶ä¸éœ€è¦ä¿å­˜è¿™ä¸ªæŸä¸ªå†…å­˜å’Œå®ƒç”¨äº†æŸä¸ªå¯„å­˜å™¨æ¥åˆå§‹åŒ–çš„å…³ç³», æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ `symbol_table` çš„ `index` æ¥è¦†ç›–è¿™ä¸ªå€¼, æ²¡æœ‰å½±å“.

æœ€å `RISC-V` éƒ¨åˆ†ä¸éœ€è¦ä¿®æ”¹, å› ä¸º `koopa` ä»£ç çš„å¯ç”¨æŒ‡ä»¤æ²¡æœ‰ä¿®æ”¹.

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv5 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv5 /root/compiler
```

## Lv6

è¿™éƒ¨åˆ†æˆ‘ä»¬éœ€è¦å®Œæˆ `if` è¯­å¥çš„ç¼–è¯‘, ç¤ºä¾‹å¦‚ä¸‹:

```cpp
int main() 
{
  int a = 1;
  if (a == 2 || a == 3) 
  {
    return 0;
  } 
  else 
  {
    return a + 1;
  }
}
```

æœ‰å¦‚ä¸‹å‡ ä¸ªé‡ç‚¹:

1. ç”Ÿæˆ `Koopa` ä¸­é—´ä»£ç æ—¶è§£å†³åˆ†æ”¯è¯­å¥åœ¨è¯­æ³•åˆ†æçš„æ—¶å€™äº§ç”Ÿçš„ç§»å…¥/å½’çº¦å†²çª.
2. ç”Ÿæˆ `Koopa` ä¸­é—´ä»£ç æ—¶å¤š `if` çš„ç¼–å·é—®é¢˜.
3. ç”Ÿæˆ `Koopa` ä¸­é—´ä»£ç æ—¶è§£å†³æ§åˆ¶æµæå‰ç»“æŸçš„é—®é¢˜.
4. ç”Ÿæˆ `Koopa` ä¸­é—´ä»£ç æ—¶è§£å†³åŒä¸€å±‚çº§å¤šæ¬¡åˆ†é…ç›¸åŒåç§°çš„å†…å­˜çš„é—®é¢˜.
5. ç”Ÿæˆ `Koopa` ä¸­é—´ä»£ç æ—¶é€»è¾‘è¿ç®—çŸ­è·¯æ±‚å€¼çš„ç‰¹æ€§.
6. ç”Ÿæˆ `RISC-V` æ±‡ç¼–ä»£ç æ—¶æ·»åŠ ä¸¤æ¡ `RISC-V` æŒ‡ä»¤.
7. ç”Ÿæˆ `RISC-V` æ±‡ç¼–ä»£ç æ—¶å®¹æ˜“å‡ºç°çš„ bug å’Œè§£å†³æ–¹æ³•, ä¸»è¦æ˜¯ 12 ä½ç«‹å³æ•°æº¢å‡ºçš„é—®é¢˜.

### Shift/Reduce Conflict

`If` ç›¸å…³çš„è¯­æ³•è§„åˆ™å¦‚ä¸‹:

```bash
Stmt ::= "if" "(" Exp ")" Stmt ["else" Stmt]
```

å¯¹äºç§»å…¥/å½’çº¦å†²çªçš„åŸå› åˆ†æå¯ä»¥å‚è€ƒ [Lv6 çš„ Lab æ–‡æ¡£](https://pku-minic.github.io/online-doc/#/lv6-if/if-else), è¿™é‡Œä¸å†èµ˜è¿°.

ä¸ºäº†é¿å…è¿™æ ·çš„é—®é¢˜, `SysY` çš„è¯­ä¹‰è§„å®šäº† `else` å¿…é¡»å’Œæœ€è¿‘çš„ `if` è¿›è¡ŒåŒ¹é…, åŠ©æ•™åœ¨è¿™é‡Œæç¤ºæ‹†åˆ†å¯ä»¥è§£å†³é—®é¢˜, é‚£ä¹ˆå…·ä½“æ€ä¹ˆåšå‘¢?

ä¸€ä¸ªé‡è¦çš„è§‚å¯Ÿæ˜¯, å¦‚æœä¸€ä¸ª `if ...` è¯­å¥åœ¨è¯­æ³•åˆ†æåè·Ÿéšäº†ä¸€ä¸ª `else ...` è¯­å¥, é‚£ä¹ˆè¿™ä¸ª `if ...` è¯­å¥å†…éƒ¨ä¸­æ‰€æœ‰å¯èƒ½å‡ºç°çš„ `if ...` è¯­å¥éƒ½å¿…é¡»æ˜¯è·Ÿéš `else ...` è¯­å¥çš„, å¦åˆ™å°±å’Œ `SysY` çš„è¯­ä¹‰è§„å®šå†²çªäº†.

å› æ­¤æˆ‘ä»¬å¯ä»¥å°†åŸæœ‰çš„è¯­æ³•è§„åˆ™ä¿®æ”¹ä¸º:

```bash
Stmt ::= "if" "(" Exp ")" Stmt
       | "if" "(" Exp ")" StmtWithElse "else" Stmt

StmtWithElse ::= "if" "(" Exp ")" StmtWithElse "else" StmtWithElse
```

è¿™æ ·å°±å¯ä»¥è§£å†³ç§»å…¥/å½’çº¦å†²çªçš„é—®é¢˜äº†.

åœ¨ Parser ä¸­çš„å‚è€ƒå®ç°:

```cpp
/* ast.hpp */

class StmtAST : public BaseAST
{
public:
    enum class StmtType
    {
        Assign,
        Expression,
        Block,
        Return,
        If
    };
    StmtType stmt_type;
    std::optional<std::unique_ptr<BaseAST>> lval;             // è¯­å¥ä¸­çš„å·¦å€¼
    std::optional<std::unique_ptr<BaseAST>> exp;              // è¯­å¥ä¸­çš„è¡¨è¾¾å¼
    std::optional<std::unique_ptr<BaseAST>> block;            // è¯­å¥ä¸­çš„åŸºæœ¬å—, å…¶å®æ˜¯å¦ä¸€ä¸ªç”¨å¤§æ‹¬å·åŒ…è£¹çš„è¯­å¥å—
    std::optional<std::unique_ptr<BaseAST>> inside_if_stmt;   // if ... ä¸­çš„è¯­å¥å—
    std::optional<std::unique_ptr<BaseAST>> inside_else_stmt; // else ... ä¸­çš„è¯­å¥å—

    Result print(std::stringstream &output_stream) const override;
};

/* sysy.y */

Stmt
  // Assign, Expression, Block, Return ...
  | IF '(' Exp ')' Stmt {
    // ...
  }
  | IF '(' Exp ')' StmtWithElse ELSE Stmt {
    // ...
  }
  ;

StmtWithElse
  // Assign, Expression, Block, Return ...
  | IF '(' Exp ')' StmtWithElse ELSE StmtWithElse {
    // ...
  }
  ;
```

ä¸ºä»€ä¹ˆæˆ‘æŠŠ `StmtWithElse` å’Œ `Stmt` çš„è¯­æ³•è§„åˆ™åˆ†å¼€å†™, é‡å¤å†™äº†ä¸€é `Stmt` ä¸­çš„å…¶å®ƒå†…å®¹å‘¢?

å› ä¸ºå¯¹äº `Stmt` æ¥è¯´, æ— æ³•åœ¨è§„çº¦çš„æ—¶å€™ä¼ é€’ä¸€ä¸ªå‚æ•°è¯´æ˜è¿™ä¸ª `Stmt` æ˜¯æœ‰ `else ...` è¯­å¥çš„, è¿˜æ˜¯æ²¡æœ‰ `else ...` è¯­å¥çš„, æ‰€ä»¥éœ€è¦æ–°å¼€ä¸€ä¸ªè¯­æ³•è§„åˆ™. åŒæ—¶æˆ‘åˆä¸æƒ³å¤§å¹…ä¿®æ”¹ `Stmt` åŸå§‹çš„è¯­æ³•è§„åˆ™, æƒ³è¦ä¿æŒå‰åçš„ä¸€è‡´æ€§, æ‰€ä»¥åªèƒ½å¤åˆ¶ä¸€é `Stmt` ä¸­çš„å…¶å®ƒè¯­æ³•è§„åˆ™åˆ° `StmtWithElse` ä¸­äº†.

### Multiple If Statement

ä¸åŒçš„ `if` è¯­å¥éƒ½æœ‰è‡ªå·±çš„ `%then`, `%else` å’Œ `%end` æ ‡ç­¾, æ‰€ä»¥éœ€è¦ä¸€ä¸ªè®¡æ•°å™¨æ¥åŒºåˆ†ä¸åŒçš„ `if` è¯­å¥, è¿™ä¸ªæ ‡ç­¾åªè¦é‡è§ä¸€æ¬¡ `if ...` è¯­å¥å°±åŠ ä¸€, è¿™æ ·å°±å¯ä»¥åŒºåˆ†ä¸åŒçš„ `if` è¯­å¥äº†.

å…·ä½“çš„è¾“å‡ºä»£ç å¯ä»¥å‚è€ƒ:

```cpp
/* koopa.cpp */

koopa_context_manager.total_if_else_statement_count++; // æ¯é‡è§ä¸€æ¬¡ if ... è¯­å¥, å°±åŠ ä¸€
std::string then_label = "%then_" + std::to_string(koopa_context_manager.total_if_else_statement_count);
std::string else_label = "%else_" + std::to_string(koopa_context_manager.total_if_else_statement_count);
std::string end_label = "%end_" + std::to_string(koopa_context_manager.total_if_else_statement_count);

Result exp_result = (*exp)->print(output_stream);

output_stream << "\tbr " << exp_result << ", " << then_label << ", " << (inside_else_stmt ? else_label : end_label) << std::endl;
```

### Handle Control Flow Early End

å…ˆæ¥çœ‹ä¸€ä¸ªä¾‹å­:

```cpp
int main() 
{
  if (0) 
  {
    return 1;
  } 
  else 
  {
    return 2;
  }
}
```

å¦‚æœæˆ‘ä»¬ naive åœ°å®ç° `if` è¯­å¥çš„ `koopa` è¾“å‡º, æ¯”å¦‚è¿™æ ·:

```cpp
/* koopa.cpp */

Result StmtAST::print(std::stringstream &output_stream) const
{
    if (stmt_type == StmtType::Assign)
    {
        // ...
    }
    else if (stmt_type == StmtType::Return)
    {
        // ...
    }
    else if (stmt_type == StmtType::Expression)
    {
        // ...
    }
    else if (stmt_type == StmtType::Block)
    {
        // ...
    }
    else if (stmt_type == StmtType::If)
    {
        koopa_context_manager.total_if_else_statement_count++;
        std::string then_label = "%then_" + std::to_string(koopa_context_manager.total_if_else_statement_count);
        std::string else_label = "%else_" + std::to_string(koopa_context_manager.total_if_else_statement_count);
        std::string end_label = "%end_" + std::to_string(koopa_context_manager.total_if_else_statement_count);

        // è®¡ç®—è¡¨è¾¾å¼, æ ¹æ®è¡¨è¾¾å¼ç»“æœè·³è½¬åˆ°ä¸åŒçš„åˆ†æ”¯
        Result exp_result = (*exp)->print(output_stream);
        output_stream << "\tbr " << exp_result << ", " << then_label << ", " << (inside_else_stmt ? else_label : end_label) << std::endl;

        // è¿›å…¥ if è¯­å¥å—
        output_stream << then_label << ":" << std::endl;
        Result result_if = (*inside_if_stmt)->print(output_stream);
        output_stream << "\tjump " << end_label << std::endl;

        // else è¯­å¥å—
        Result result_else = Result();
        if (inside_else_stmt)
        {
            output_stream << else_label << ":" << std::endl;
            result_else = (*inside_else_stmt)->print(output_stream);
            output_stream << "\tjump " << end_label << std::endl;
        }

        Result result = Result();
        return result;
    }
    else
    {
        throw std::runtime_error("StmtAST::print: invalid statement");
    }
}
```

é¦–å…ˆå›å¿†åŸºæœ¬å—çš„å®šä¹‰:

> åŸºæœ¬å— (basic block) æ˜¯ç¼–è¯‘é¢†åŸŸçš„ä¸€ä¸ªå¾ˆå¸¸è§çš„æ¦‚å¿µ, å®ƒæŒ‡çš„æ˜¯ä¸€ç³»åˆ—æŒ‡ä»¤çš„é›†åˆ, åŸºæœ¬å—æ»¡è¶³:
> - åªæœ‰ä¸€ä¸ªå…¥å£ç‚¹: æ‰€æœ‰åŸºæœ¬å—ä¸­çš„æŒ‡ä»¤å¦‚æœè¦æ‰§è¡Œè·³è½¬, åªèƒ½è·³åˆ°æŸä¸ªåŸºæœ¬å—çš„å¼€å¤´, è€Œä¸èƒ½è·³åˆ°ä¸­é—´.
> - åªæœ‰ä¸€ä¸ªå‡ºå£ç‚¹: åŸºæœ¬å—ä¸­, åªæœ‰æœ€åä¸€æ¡æŒ‡ä»¤èƒ½è¿›è¡Œæ§åˆ¶æµçš„è½¬ç§», ä¹Ÿå°±æ˜¯è·³åˆ°å…¶ä»–åŸºæœ¬å—, æˆ–è€…ä»å‡½æ•°ä¸­è¿”å› (æ‰§è¡Œ return æ“ä½œ).
> åŸºæœ¬å—çš„å­˜åœ¨å¯ä»¥ç®€åŒ–å¾ˆå¤šç¼–è¯‘è¿‡ç¨‹ä¸­éœ€è¦è¿›è¡Œçš„åˆ†æ, æ‰€ä»¥ Koopa IR è¦æ±‚å‡½æ•°ä¸­çš„æŒ‡ä»¤å¿…é¡»é¢„å…ˆæŒ‰ç…§åŸºæœ¬å—åˆ†ç±». åŒæ—¶, Koopa IR çº¦å®š, å‡½æ•°çš„ç¬¬ä¸€ä¸ªåŸºæœ¬å—ä¸ºå‡½æ•°çš„å…¥å£åŸºæœ¬å—, ä¹Ÿå°±æ˜¯æ‰§è¡Œå‡½æ•°æ—¶, é¦–å…ˆä¼šæ‰§è¡Œç¬¬ä¸€ä¸ªåŸºæœ¬å—ä¸­çš„æŒ‡ä»¤.

é‚£ä¹ˆæˆ‘ä»¬å¯èƒ½ä¼šå¾—åˆ°è¿™æ ·çš„ `koopa` ä»£ç , æ³¨æ„å…¶ä¸­çš„ `%then_1` å’Œ `%else_1` åœ¨è¿”å›åå­˜åœ¨è·³è½¬åˆ° `%end_1` çš„æŒ‡ä»¤, è¿™å’ŒåŸºæœ¬å—çš„å®šä¹‰ (åªæœ‰æœ€åä¸€æ¡æŒ‡ä»¤èƒ½è¿›è¡Œæ§åˆ¶æµçš„è½¬ç§») å†²çªäº†, ä»è€Œä¼šé€ æˆç¼–è¯‘å™¨åç«¯çš„é”™è¯¯.

```asm
fun @main(): i32 {
%entry:
    br 0, %then_1, %else_1
%then_1:
    ret 1
    jump %end_1
%else_1:
    ret 2
    jump %end_1
%end_1:
ret 0
}
```

æ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨è¾“å‡º `if` å†…éƒ¨çš„ `jump` å‰åˆ¤æ–­æ”¹æ§åˆ¶æµæ˜¯å¦æå‰è¢« `ret` æ‰“æ–­äº†, å¦‚æœè¢«æ‰“æ–­äº†å°±ä¸è¾“å‡º `jump` äº†.

ä¸€ä¸ªéå¸¸ç›´è§‚çš„æƒ³æ³•æ˜¯åœ¨æ¯ä¸€ä¸ª `print` å‡½æ•°çš„è¾“å‡º `Result` ä¸­åŠ å…¥ä¸€ä¸ª `bool` å˜é‡, è¡¨ç¤ºè¿™ä¸ªè¯­å¥ä»¥åŠå…¶åµŒå¥—çš„è¯­å¥å†…æ˜¯å¦è¢« `ret` è¯­å¥æ˜¾å¼åœ°è¿”å›äº†, ç„¶åæ ¹æ®è¿™ä¸ªå˜é‡æ¥å†³å®šæ˜¯å¦è¾“å‡º `jump` æŒ‡ä»¤, åŒæ—¶è¿˜å¯ä»¥æå‰åœæ­¢è¾“å‡º, æé«˜ä»£ç è¿è¡Œæ•ˆç‡.

```cpp
/* koopa.cpp */

Result StmtAST::print(std::stringstream &output_stream) const
{
    if (stmt_type == StmtType::Assign)
    {
        // ...
    }
    else if (stmt_type == StmtType::Return)
    {
        if (!lval && exp && !block)
        {
            Result result = (*exp)->print(output_stream);
            output_stream << "\tret " << result << "\n";
            result.control_flow_returned = true; // å¦‚æœè¯­å¥è¿”å›äº†, å°±è®¾ç½®è¯¥æ§åˆ¶æµè¿”å›
            return result;
        }
        else if (!lval && !exp && !block)
        {
            output_stream << "\tret\n";
            Result result = Result();
            result.control_flow_returned = true; // å¦‚æœè¯­å¥è¿”å›äº†, å°±è®¾ç½®è¯¥æ§åˆ¶æµè¿”å›
            return result;
        }
        else
        {
            throw std::runtime_error("StmtAST::print: invalid return statement");
        }
    }
    else if (stmt_type == StmtType::Expression)
    {
        // ...
    }
    else if (stmt_type == StmtType::Block)
    {
        if (!lval && !exp && block)
        {
            Result result = (*block)->print(output_stream);
            return result;
        }
        else
        {
            throw std::runtime_error("StmtAST::print: invalid block statement");
        }
    }
    else if (stmt_type == StmtType::If)
    {
        koopa_context_manager.total_if_else_statement_count++;
        std::string then_label = "%then_" + std::to_string(koopa_context_manager.total_if_else_statement_count);
        std::string else_label = "%else_" + std::to_string(koopa_context_manager.total_if_else_statement_count);
        std::string end_label = "%end_" + std::to_string(koopa_context_manager.total_if_else_statement_count);

        Result exp_result = (*exp)->print(output_stream);
        if (!inside_if_stmt && !inside_else_stmt)
        {
            throw std::runtime_error("StmtAST::print: invalid if statement, there's no if");
        }

        output_stream << "\tbr " << exp_result << ", " << then_label << ", " << (inside_else_stmt ? else_label : end_label) << std::endl;

        // if è¯­å¥å—
        output_stream << then_label << ":" << std::endl;
        Result result_if = (*inside_if_stmt)->print(output_stream);

        // å¦‚æœ if è¯­å¥å—æ˜¾å¼çš„è¿”å›äº†, å°±ä¸è¦è·³è½¬äº†, å¦åˆ™è¾“å‡ºè¿™æ ·çš„ koopa ä»£ç æ˜¯é”™è¯¯çš„:
        // fun @main(): i32 {
        // %entry:
        //     br 0, %then_1, %else_1
        // %then_1:
        //     ret 1
        //     jump %end_1
        // %else_1:
        //     ret 2
        //     jump %end_1
        // %end_1:
        // }
        if (!result_if.control_flow_returned)
        {
            output_stream << "\tjump " << end_label << std::endl;
        }

        // else è¯­å¥å—
        Result result_else = Result();
        if (inside_else_stmt)
        {
            output_stream << else_label << ":" << std::endl;

            result_else = (*inside_else_stmt)->print(output_stream);

            // å¦‚æœ else è¯­å¥å—æ˜¾å¼çš„è¿”å›äº†, å°±ä¸è¦è·³è½¬äº†
            if (!result_else.control_flow_returned)
            {
                output_stream << "\tjump " << end_label << std::endl;
            }
        }

        // å¦‚æœ if è¯­å¥å—å’Œ else è¯­å¥å—éƒ½è¿”å›äº†, åˆ™æ³¨æ˜æ•´ä¸ª if ... else ... è¯­å¥å—è¿”å›äº†
        // ä½†æ˜¯ä¸ºäº†é¿å…è¿™æ ·çš„ç©º %end , å¦‚æœå·²ç»ç»“æŸäº†å°±ä¸è¾“å‡º %end äº†
        // fun @main(): i32 {
        // %entry:
        // 	   br 0, %then_1, %else_1
        // %then_1:
        //     ret 1
        // %else_1:
        //     ret 2
        // %end_1:
        // }
        Result result = Result();
        if (!result_if.control_flow_returned || !result_else.control_flow_returned)
        {
            output_stream << end_label << ":" << std::endl;
        }
        else
        {
            result.control_flow_returned = true; // å¦‚æœæ˜¯ if ... else ... è¯­å¥, åˆ™ if ... å’Œ else ... è¯­å¥å—éƒ½è¿”å›äº†æ‰è®¾ç½®æ•´ä½“å‡½æ•°è¿”å›
        }
        return result;
    }
    else
    {
        throw std::runtime_error("StmtAST::print: invalid statement");
    }
}
```

æœ€åç»™ `FuncDefAST` çš„ `print` å‡½æ•°åŠ ä¸Šæ§åˆ¶æµè¿”å›çš„åˆ¤æ–­, å¦‚æœ `block` æ²¡æœ‰æ˜¾å¼çš„ `ret` æŒ‡ä»¤, åˆ™è¡¥ä¸Šä¸€ä¸ª `ret 0`.

```cpp
/* koopa.cpp */

Result FuncDefAST::print(std::stringstream &output_stream) const
{
    output_stream << "fun @" << ident << "(): ";
    func_type->print(output_stream);
    output_stream << " {" << std::endl;
    output_stream << "%entry:" << std::endl;
    Result result = block->print(output_stream);
    // å¦‚æœ block æ²¡æœ‰æ˜¾å¼çš„ ret æŒ‡ä»¤, åˆ™è¡¥ä¸Šä¸€ä¸ª ret 0
    if (!result.control_flow_returned)
    {
        output_stream << "\tret 0" << std::endl;
    }
    output_stream << "}" << std::endl;
    return result;
}
```

### Handle Same Variable Name in Same Level

ä¸€ä¸ªä¾‹å­:

```cpp
int main()
{
    {
        int a = 2;
    }
    {
        int a = 3;
    }
    return 0;
}
```

å¦‚æœæŒ‰ç…§æˆ‘ä»¬ä¹‹å‰çš„å¤„ç†æ–¹å¼, ä¼šå¾—å‡ºè¿™æ ·çš„ `koopa` ä»£ç :

```asm
fun @main(): i32 {
%entry:
    @a_2 = alloc i32
    store 2, @a_2
    @a_2 = alloc i32
    sstore 3, @a_2
    ret 0
}
```

è¿™ä¸‹å°±å‡ºé—®é¢˜äº†, å› ä¸º `@a_2` è¢«åˆ†é…äº†ä¸¤æ¬¡. ä½†æ˜¯è¿™ä»¶äº‹æƒ…å¾ˆå¥½å¤„ç†, åªè¦ç»´æŠ¤ä¸€ä¸ª `std::map<std::pair<std::string, int>, int>` æ¥è®°å½•æ¯ä¸ªå˜é‡ååœ¨æ¯ä¸ªå±‚çº§ä¸­æ˜¯å¦å·²ç»åˆ†é…äº†, ç„¶åæ¯æ¬¡åˆ†é…å˜é‡çš„æ—¶å€™, å…ˆæ£€æŸ¥è¿™ä¸ªå˜é‡åæ˜¯å¦å·²ç»å­˜åœ¨, å¦‚æœå­˜åœ¨å°±ä½¿ç”¨è¿™ä¸ªå˜é‡çš„åœ°å€, å¦åˆ™å°±åˆ†é…ä¸€ä¸ªæ–°çš„åœ°å€.

```cpp
/* koopa_util.hpp */

class KoopaContextManager
{
private:
    // ...
    // ç”¨äºåˆ¤æ–­å½“å‰ç¬¦å·æ˜¯å¦åœ¨å½“å‰ä¸‹æ ‡è¢«åˆ†é…, æ¯”å¦‚ @a_1 åœ¨ symbol_tables[0] ä¸­è¢«åˆ†é…, é‚£ä¹ˆ is_symbol_allocated_in_this_level[std::make_pair("a", 1)] == true
    std::map<std::pair<std::string, int>, bool> _is_symbol_allocated_in_this_level;

public:
    // ...
};

/* koopa.cpp */

Result VarDefAST::print(std::stringstream &output_stream) const
{
    if (var_init_val)
    {
        Result value_result = (*var_init_val)->print(output_stream);
        koopa_context_manager.insert_symbol(var_symbol, Symbol(Symbol::Type::VAR, value_result.val));
        std::string symbol_name = var_symbol;
        std::string suffix = std::to_string(koopa_context_manager.name_to_symbol(symbol_name).val);
        std::string symbol_name_with_suffix = symbol_name + "_" + suffix;
        // å¦‚æœè¿™ä¸ªå˜é‡ååœ¨å½“å‰å±‚çº§ä¸­æ²¡æœ‰è¢«åˆ†é…è¿‡, åˆ™åˆ†é…ä¸€ä¸ªæ–°çš„åœ°å€
        if (!koopa_context_manager.is_symbol_allocated_in_this_level(symbol_name))
        {
            output_stream << "\t@" << symbol_name_with_suffix << " = alloc i32\n";
        }
        koopa_context_manager.set_symbol_allocated_in_this_level(symbol_name);
        output_stream << "\tstore " << value_result << ", @" << symbol_name_with_suffix << "\n";
    }
    else
    {
        koopa_context_manager.insert_symbol(var_symbol, Symbol(Symbol::Type::VAR, 0));
        std::string symbol_name = var_symbol;
        std::string suffix = std::to_string(koopa_context_manager.name_to_symbol(symbol_name).val);
        std::string symbol_name_with_suffix = symbol_name + "_" + suffix;
        // å¦‚æœè¿™ä¸ªå˜é‡ååœ¨å½“å‰å±‚çº§ä¸­æ²¡æœ‰è¢«åˆ†é…è¿‡, åˆ™åˆ†é…ä¸€ä¸ªæ–°çš„åœ°å€
        if (!koopa_context_manager.is_symbol_allocated_in_this_level(symbol_name))
        {
            output_stream << "\t@" << symbol_name_with_suffix << " = alloc i32\n";
        }
        koopa_context_manager.set_symbol_allocated_in_this_level(symbol_name);
    }
    return Result();
}
```

### Short-circuit Evaluation of Logical Expressions

ç¼–è¯‘å™¨å¯¹é€»è¾‘è¿ç®—, æ¯”å¦‚ `||` å®é™…ä¸Šæ˜¯åšäº†å¦‚ä¸‹æ“ä½œ:

```cpp
int result = 1;

if (lhs == 0) 
{
  result = rhs != 0;
}
```

è¿™æ ·å½“ `lhs == 1` æ—¶, ç¼–è¯‘å™¨ä¼šç›´æ¥è¿”å› `result`, è€Œä¸ä¼šè®¡ç®— `rhs` çš„å€¼.

åœ¨å…·ä½“å®ç°çš„æ—¶å€™ä½ å¯ä»¥å¯¹ `lhs` çš„è¿”å›å€¼è¿›è¡Œåˆ¤æ–­, å¦‚æœæ˜¯ç«‹å³æ•°å°±ä¸è¦ä½¿ç”¨è·³è½¬æŒ‡ä»¤, è¿™æ ·å¯èƒ½ä¼šé€ æˆå¸¸é‡è¡¨è¾¾å¼çš„æ±‚å€¼å¤±è´¥.

å¦‚æœç¼–è¯‘æœŸæ— æ³•ç¡®å®šæ˜¯å¦å¯ä»¥çŸ­è·¯æ±‚å€¼, æˆ‘ä»¬éœ€è¦ä½¿ç”¨å†…å­˜æ¥ä¿å­˜é€»è¾‘è¡¨è¾¾å¼çš„ç»“æœ. å‡è®¾ç¬¬ä¸€ä¸ªæ“ä½œæ•°å­˜åœ¨äº† `%1` è¿™ä¸ªå¯„å­˜å™¨ä¸­, ç¼–è¯‘æœŸæˆ‘ä»¬ä¸çŸ¥é“ç¬¬äºŒä¸ªæ“ä½œæ•° `%2` æ˜¯å¦å­˜åœ¨, æ‰€ä»¥æ— æ³•è¿”å› `or` è¡¨è¾¾å¼æ•´ä½“çš„ç­”æ¡ˆå­˜åœ¨å“ªé‡Œäº†, æ‰€ä»¥éœ€è¦ç»“æœå­˜åœ¨å†…å­˜ä¸­ä»¥ä¿è¯å¯ä»¥ä¿®æ”¹.

ä¸€ä¸ªçŸ­è·¯æ±‚å€¼ç¤ºä¾‹å¦‚ä¸‹:

```cpp
int main() 
{
    int x = 1;
    int y = 0;
    return x || y;
}
```

å¯¹åº”çš„ `koopa` ä»£ç å¦‚ä¸‹:

```asm
fun @main(): i32 {
%entry:
	@x_1 = alloc i32
	store 1, @x_1
	@y_1 = alloc i32
	store 0, @y_1
	%0 = load @x_1
	%1 = ne %0, 0
	@or_result_in_memory_1 = alloc i32
	store %1, @or_result_in_memory_1
	br %1, %or_end_1, %or_second_operator_1
%or_second_operator_1:
	%2 = load @y_1
	%3 = ne %2, 0
	%4 = or %1, %3
	store %4, @or_result_in_memory_1
	jump %or_end_1
%or_end_1:
	%5 = load @or_result_in_memory_1
	ret %5
}
```

å…¶ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ€åè¿”å›çš„ `%5` æ˜¯ `@or_result_in_memory_1` è¿™ä¸ªå†…å­˜åœ°å€ä¸­çš„å€¼, è¿™ä¸ªå†…å­˜åœ°å€ä¸­ä¿å­˜çš„å€¼æœ‰å¯èƒ½æ¥æºäº `%1` è¿™ä¸ªå¯„å­˜å™¨, å¯¹åº” `lhs` çš„å€¼, ä¹Ÿæœ‰å¯èƒ½æ¥æºäº `%4` è¿™ä¸ªå¯„å­˜å™¨, å¯¹åº” `rhs` çš„å€¼. ä¸ºäº†é¿å…ä¸çŸ¥é“è¿”å› `%1` è¿˜æ˜¯ `%4` çš„æƒ…å†µ, æˆ‘ä»¬ä½¿ç”¨å†…å­˜æ¥ä¿å­˜ç»“æœ, æœ€åä»å†…å­˜ä¸­è¯»å–ç»“æœåˆ° `%5` ä¸­å³å¯.

ä¸€ä¸ªå¯èƒ½çš„å®ç°æ–¹å¼å¦‚ä¸‹:

```cpp
/* koopa.cpp */

Result LOrExpAST::print(std::stringstream &output_stream) const
{
    if (!left_or_exp && !op && left_and_exp)
    {
        return (*left_and_exp)->print(output_stream);
    }
    else if (left_or_exp && op && left_and_exp)
    {
        Result result_left = (*left_or_exp)->print(output_stream);

        if (result_left.type == Result::Type::IMM && result_left.val != 0) // ç«‹å³æ•°é 0
        {
            return Result(Result::Type::IMM, 1);
        }
        else if (result_left.type == Result::Type::IMM && result_left.val == 0) // ç«‹å³æ•° 0
        {
            Result result_right = (*left_and_exp)->print(output_stream);
            if (result_right.type == Result::Type::IMM)
            {
                return Result(Result::Type::IMM, 0 || result_right.val);
            }
            else
            {
                Result temp = Result(Result::Type::REG);
                output_stream << "\t" << temp << " = ne " << result_right << ", 0\n";
                return temp;
            }
        }
        else if (result_left.type == Result::Type::REG) // å¦‚æœæ˜¯å¯„å­˜å™¨, ä¸èƒ½åœ¨ç¼–è¯‘æœŸå®ŒæˆçŸ­è·¯æ±‚å€¼, å°±éœ€è¦è·³è½¬æ¥å®ŒæˆçŸ­è·¯æ±‚å€¼, å¦‚æœåˆ¤æ–­å¯„å­˜å™¨æ˜¯ 0 ç›´æ¥è·³è½¬åˆ° or_end_label
        {
            // æ¯è¿›å…¥ä¸€ä¸ªéœ€è¦ç”¨åˆ†æ”¯è·³è½¬è¯­å¥è¾¾æˆçŸ­è·¯æ±‚å€¼çš„ || è¯­å¥, å°±è®¾ç½®ä¸€ä¸ªè·³è½¬æ ‡ç­¾
            koopa_context_manager.total_or_statement_count++;

            // è®¾ç½®è·³è½¬æ ‡ç­¾
            std::string or_second_operator_label = "%or_second_operator_" + std::to_string(koopa_context_manager.total_or_statement_count);
            std::string or_end_label = "%or_end_" + std::to_string(koopa_context_manager.total_or_statement_count);

            // å‡è®¾ç¬¬ä¸€ä¸ªæ“ä½œæ•°å­˜åœ¨äº† %1 è¿™ä¸ªå¯„å­˜å™¨ä¸­, ç¼–è¯‘æœŸä¸çŸ¥é“ç¬¬äºŒä¸ªæ“ä½œæ•° %2 æ˜¯å¦å­˜åœ¨, æ‰€ä»¥æ— æ³•è¿”å› or è¡¨è¾¾å¼æ•´ä½“çš„ç­”æ¡ˆå­˜åœ¨å“ªé‡Œäº†, æ‰€ä»¥éœ€è¦ç»“æœå­˜åœ¨å†…å­˜ä¸­ä»¥ä¿è¯å¯ä»¥ä¿®æ”¹
            std::string or_result_in_memory = "@or_result_in_memory_" + std::to_string(koopa_context_manager.total_or_statement_count);

            // å¦‚æœç¬¬ä¸€ä¸ªæ“ä½œæ•°æ˜¯ 0, åˆ™è·³è½¬åˆ° or_second_operator_label çœ‹çœ‹ç¬¬äºŒä¸ªæ“ä½œæ•°æ˜¯å¦æ˜¯ 0, å¦åˆ™è·³è½¬åˆ° or_end_label
            Result temp_1 = Result(Result::Type::REG);
            output_stream << "\t" << temp_1 << " = ne " << result_left << ", 0\n";
            output_stream << "\t" << or_result_in_memory << " = alloc i32\n";
            output_stream << "\tstore " << temp_1 << ", " << or_result_in_memory << "\n";
            output_stream << "\tbr " << temp_1 << ", " << or_end_label << ", " << or_second_operator_label << "\n";

            // è¾“å‡ºæ²¡æœ‰çŸ­è·¯æ±‚å€¼çš„æ§åˆ¶æµ label
            output_stream << or_second_operator_label << ":" << std::endl;

            // è®¡ç®—ç¬¬äºŒä¸ªæ“ä½œæ•°
            Result result_right = (*left_and_exp)->print(output_stream);
            Result temp_2 = Result(Result::Type::REG);
            Result temp_3 = Result(Result::Type::REG);
            output_stream << "\t" << temp_2 << " = ne " << result_right << ", 0\n";
            output_stream << "\t" << temp_3 << " = or " << temp_1 << ", " << temp_2 << "\n";
            output_stream << "\tstore " << temp_3 << ", " << or_result_in_memory << "\n";
            output_stream << "\tjump " << or_end_label << "\n";

            // è¾“å‡ºçŸ­è·¯æ±‚å€¼ä¹‹åçš„æ§åˆ¶æµåˆå¹¶ label
            output_stream << or_end_label << ":" << std::endl;

            // æŠŠç»“æœä»å†…å­˜ä¸­è¯»å–åˆ°å¯„å­˜å™¨ä¸­
            Result result = Result(Result::Type::REG);
            output_stream << "\t" << result << " = load " << or_result_in_memory << "\n";
            return result;
        }
        else
        {
            throw std::runtime_error("LOrExpAST::print: invalid first operand of logical OR expression");
        }
    }
    else
    {
        throw std::runtime_error("LOrExpAST::print: invalid logical OR expression");
    }
}
```

### Generate RISC-V Branch Code

åœ¨å®Œæˆäº† `koopa` çš„ç”Ÿæˆå, æˆ‘ä»¬å°±å¯ä»¥å¼€å§‹ç”Ÿæˆ `RISC-V` çš„æ±‡ç¼–ä»£ç äº†. 

å…·ä½“æ¥è®²åªéœ€è¦å®ç° `bnez` å’Œ `j` è¿™ä¸¤ä¸ª `RISC-V` æŒ‡ä»¤çš„ç”Ÿæˆä»¥æ»¡è¶³ `br` å’Œ `jump` è¿™ä¸¤ä¸ª `koopa` æŒ‡ä»¤çš„ç”Ÿæˆå³å¯, éš¾åº¦ä¸å¤§.

```cpp
/* riscv.cpp */

// è®¿é—® branch æŒ‡ä»¤, è¿™ä¸ªæŒ‡ä»¤çš„è¾“å…¥æ˜¯ç«‹å³æ•°æˆ–å†…å­˜, æ‰€ä»¥éœ€è¦åˆ¤æ–­ branch.cond->kind.tag
void visit(const koopa_raw_branch_t &branch, const koopa_raw_value_t &value)
{
    // å½“å‰å‡½æ•°çš„ StackManager
    StackManager &stack_manager = riscv_context_manager.get_current_function_stack_manager();
    // ç»™ä¸­é—´ç»“æœåˆ†é…ä¸€ä¸ªå¯„å­˜å™¨
    riscv_context_manager.allocate_reg(value);
    std::string temp_reg_name = riscv_context_manager.value_to_reg_string(value);
    // ä½¿ç”¨ç«‹å³æ•°æˆ–ä»æ ˆä¸­åŠ è½½æ•°æ®åˆ°å¯„å­˜å™¨
    if (branch.cond->kind.tag == KOOPA_RVT_INTEGER)
    {
        riscv_printer.li(temp_reg_name, branch.cond->kind.data.integer.value);
    }
    else
    {
        riscv_printer.lw(temp_reg_name, "sp", stack_manager.get_value_stack_offset(branch.cond), riscv_context_manager);
    }
    // è®¿é—® branch æŒ‡ä»¤
    riscv_printer.bnez(temp_reg_name, branch.true_bb->name + 1);
    riscv_printer.jump(branch.false_bb->name + 1);
    // å½“å‰æ“ä½œæ•°æ‰€åœ¨çš„å¯„å­˜å™¨å·²ç»è¢«ä½¿ç”¨è¿‡äº†, é‡Šæ”¾
    riscv_context_manager.set_reg_free(value);
}

// è®¿é—® jump æŒ‡ä»¤
void visit(const koopa_raw_jump_t &jump)
{
    // è®¿é—® jump æŒ‡ä»¤
    riscv_printer.jump(jump.target->name + 1);
}
```

### Handle Immediate Number Overflow

ä½†æ˜¯åœ¨è¿™é‡Œ, `Lv6` çš„ `RISC-V` çš„æ‰€æœ‰æµ‹è¯•ç‚¹ä¸­æœ‰ä¸€ä¸ªå«åš `logical1` çš„æµ‹è¯•ç‚¹æ¯”è¾ƒç‰¹æ®Š, å®ƒæµ‹è¯•äº† `lw`, `sw` å’Œ `addi` è¿™ä¸‰ä¸ªæŒ‡ä»¤ä¸­ç«‹å³æ•°çš„èŒƒå›´.

<Aside title='Immediate Number Overflow First Tested Here' type='note'>

éå¸¸å¥‡æ€ªçš„æ˜¯è¿™ä¸ªç«‹å³æ•°æº¢å‡ºçš„é—®é¢˜åœ¨ [Lv4.2. å˜é‡å’Œèµ‹å€¼](https://pku-minic.github.io/online-doc/#/lv4-const-n-var/var-n-assign) ä¸­ç¬¬ä¸€æ¬¡æåˆ°, ä½†æ˜¯åˆ°äº† `Lv6` çš„ `RISC-V` ç”Ÿæˆéƒ¨åˆ†æ‰ç¬¬ä¸€æ¬¡è¢«æµ‹è¯•, å¹¶ä¸”è¿™ä¸ªæµ‹è¯•ç‚¹çš„åå­—éå¸¸å…·æœ‰è¯¯å¯¼æ€§, è®©äººä»¥ä¸ºæ˜¯é€»è¾‘è¿ç®—çš„æµ‹è¯•ç‚¹, å®é™…ä¸Šé”™è¯¯å‡ºåœ¨ `RISC-V` çš„ç«‹å³æ•°èŒƒå›´ä¸Š...

</Aside>

å›å¿† `RISC-V` çš„æŒ‡ä»¤æ ¼å¼, ç«‹å³æ•°èŒƒå›´ä¸ºåäºŒä½æ•´æ•°, å³ `-2048` åˆ° `2047`, æ‰€ä»¥è¿™ä¸‰ä¸ªæŒ‡ä»¤ä¸€æ—¦é‡åˆ°ç«‹å³æ•°è¶…è¿‡è¿™ä¸ªèŒƒå›´çš„æŒ‡ä»¤å°±éœ€è¦è¿›è¡Œé¢å¤–çš„å¤„ç†, ä»¥ `lw` ä¸ºä¾‹:

```cpp
void RISCVPrinter::lw(const std::string &rd, const std::string &base, const int &bias, RISCVContextManager &context_manager)
{
    // æ£€æŸ¥åç§»é‡æ˜¯å¦åœ¨ 12 ä½ç«‹å³æ•°èŒƒå›´å†…
    if (bias >= -2048 && bias < 2048)
    {
        std::cout << "\tlw " << rd << ", " << bias << "(" << base << ")" << std::endl;
    }
    else
    {
        std::string reg = context_manager.new_temp_reg();
        li(reg, bias);
        add(reg, reg, base);
        std::cout << "\tlw " << rd << ", " << "(" << reg << ")" << std::endl;
    }
}
```

å¹¶ä¸”æ³¨æ„æŒ‡ä»¤æ ¼å¼æ˜¯ `lw rd, bias(base)`, å…¶ä¸­ `bias` æ˜¯**ç«‹å³æ•°ä¸æ˜¯å¯„å­˜å™¨**, æ‰€ä»¥ `%0 = load @x` æŒ‡ä»¤ (å…¶ä¸­ `@x` åœ¨æ ˆåç§»é‡ä¸º 2048 çš„åœ°æ–¹) åº”è¯¥å†™æˆ:

```asm
li t1, 2048
add t1, t1, sp
lw t0, (t1)
```

è€Œä¸æ˜¯:

```asm
li t1, 2048
lw t0, t1(sp)
```

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv6 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv6 /root/compiler
```

## Lv7

è¿™ä¸ª Level éœ€è¦å®ç° `while` å’Œå®ƒé…å¥—çš„ `break` å’Œ `continue` è¯­å¥.

<Aside title='WA Cases' type='caution'>

è¿™ä¸ª Level çš„æµ‹è¯•ç‚¹ä¸­æˆ‘æœ‰ä¸¤ä¸ª WA çš„æµ‹è¯•ç‚¹, åˆ†åˆ«æ˜¯ `12_break1` å’Œ `14_summary1` . å¦‚æœæ‚¨æœ‰å…³äº `Lv7` çš„ä»»ä½• corner case çš„æµ‹è¯•ç‚¹, æ¬¢è¿å’Œæˆ‘äº¤æµ!

Update 2025-01-06: é—®é¢˜å‡ºåœ¨æ§åˆ¶æµåˆ†æå‡ºé”™. æˆ‘ä¹‹å‰è®¤ä¸ºå¦‚æœåœ¨ `while` è¯­å¥å—ä¸­æœ‰ `return` è¯­å¥, é‚£ä¹ˆ `while` è¯­å¥ä¹Ÿå‘Šè¯‰ä¸Šä¸€å±‚æ§åˆ¶æµè¿”å›äº†, ä½†æ˜¯å®é™…ä¸Šè¿™ä¸ª `while` è¯­å¥å¯èƒ½æ ¹æœ¬ä¸ä¼šè¿›å», æ˜¯å¦è¿›å…¥ `while` è¯­å¥å—å–å†³äºè¿è¡Œæ—¶æ¡ä»¶, æ‰€ä»¥æ— è®º `while` è¯­å¥å—ä¸­æ˜¯å¦å­˜åœ¨ `return` è¯­å¥, éƒ½åº”è¯¥å‘Šè¯‰ä¸Šä¸€å±‚æ§åˆ¶æµè¿˜æ²¡æœ‰è¿”å›.

</Aside>

### `While` Statement

`while` è¯­å¥çš„è¯­æ³•å¦‚ä¸‹:

```bash
Stmt ::= "while" "(" Exp ")" Stmt;
```

å’Œ `if` è¯­å¥ç±»ä¼¼, ä¸å†èµ˜è¿°.

### `Break` and `Continue` Statement

`break` å’Œ `continue` è¯­å¥çš„è¯­æ³•å¦‚ä¸‹:

```bash
Stmt ::= "break;";
       | "continue;";
```

ä¸»è¦çš„éš¾ç‚¹åœ¨äºå¦‚ä½•æ­£ç¡®è·å–è·³è½¬çš„ç›®æ ‡, å› ä¸ºè·³è½¬çš„ç›®æ ‡æ ‡ç­¾æ˜¯åœ¨è®¿é—® `while` è¯­å¥æ—¶å®šä¹‰çš„, å½“ä½ è®¿é—® `break` æˆ– `continue` è¯­å¥æ—¶, éœ€è¦è·å– `while` è¯­å¥çš„è·³è½¬ç›®æ ‡æ ‡ç­¾.

æˆ‘ä»¬é‡‡ç”¨æ ˆçš„æ–¹å¼è·å–è·³è½¬çš„ç›®æ ‡æ ‡ç­¾, å½“è¿›å…¥ `while` è¯­å¥æ—¶, æŠŠå½“å‰çš„ `while` è¯­å¥çš„åºå·å‹å…¥æ ˆä¸­, å½“è®¿é—® `break` æˆ– `continue` è¯­å¥æ—¶, ä»æ ˆä¸­è¯»å–å½“å‰çš„æ ˆé¡¶åºå·, ç„¶åç”Ÿæˆè·³è½¬æŒ‡ä»¤.

```cpp
else if (stmt_type == StmtType::Break)
{
    if (koopa_context_manager.while_statement_stack.empty())
    {
        throw std::runtime_error("StmtAST::print: invalid break statement, not in a while statement");
    }
    int current_while_statement_count = koopa_context_manager.while_statement_stack.top();
    std::string while_end_label = "%while_end_" + std::to_string(current_while_statement_count);
    output_stream << "\tjump " << while_end_label << "\n";
    Result result = Result();
    result.control_flow_while_interrupted = true;
    return result;
}
```

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv7 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv7 /root/compiler
```

## Lv8

è¿™ä¸€ç« èŠ‚éœ€è¦å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¤„ç†å‡½æ•° (åŒ…æ‹¬ SysY åº“å‡½æ•°) å’Œå…¨å±€å˜é‡çš„ç¼–è¯‘å™¨.

ç¤ºä¾‹å‡½æ•°å¦‚ä¸‹:

```c

int var;

int func(int x) 
{
  var = var + x;
  return var;
}

int main() 
{
  // putint å’Œ putch éƒ½æ˜¯ SysY åº“å‡½æ•°
  // SysY è¦æ±‚åº“å‡½æ•°ä¸å£°æ˜å°±å¯ä»¥ä½¿ç”¨
  putint(func(1));
  var = var * 10;
  putint(func(2));
  putch(10);
  return var;
}

```

### Some Simple Advice

1. ä¸­é—´ä»£ç ç”Ÿæˆéƒ¨åˆ†åªéœ€è¦æ³¨æ„é‡æ–° `load` å‡½æ•°å‚æ•°, è¿™æ ·å¯ä»¥ä¸ºç›®æ ‡ä»£ç çš„ç”Ÿæˆçœä¸€äº›äº‹, å…·ä½“æ¥è®², å¦‚æœè¿™æ ·åšäº†ä¹‹ååªæœ‰ `load` æŒ‡ä»¤å¯èƒ½æ”¶åˆ° `KOOPA_RVT_GLOBAL_ALLOC` è¿™ä¸ªä»£è¡¨å‡½æ•°å‚æ•°çš„ `tag`, å…¶ä»–å‡½æ•°ä¸ç”¨ä¿®æ”¹.
2. åœ¨è¿›å…¥ä¸€ä¸ªæ–°å‡½æ•°å, è¦åœ¨é¡¶éƒ¨ä¿å­˜ `ra` å¯„å­˜å™¨, åœ¨é€€å‡ºå‡½æ•°åæ¢å¤ `ra` å¯„å­˜å™¨, æ‰€ä»¥æ ˆå¤§å°è¦å¤šåŠ ä¸€, å¤šåˆ†é…ä¸€æ¡ store æŒ‡ä»¤æ¥å­˜å‚¨ ra å¯„å­˜å™¨, ra æ˜¯è°ƒç”¨è€…ä¿å­˜å¯„å­˜å™¨, è°ƒç”¨è€…æŠŠå®ƒçš„ ra å­˜åœ¨æ¯ä¸ªæ ˆå¸§çš„æœ€ä¸Šé¢, è°ƒç”¨å‡½æ•°ä¹‹å‰ä¿®æ”¹è¿™ä¸ªå¯„å­˜å™¨ä¸º call çš„ä¸‹ä¸€æ¡æŒ‡ä»¤, ç„¶åè¿›å…¥ä¸‹ä¸€ä¸ªå‡½æ•°, ä»£è¡¨è°ƒç”¨è€…çš„ä¸‹ä¸€æ¡æŒ‡ä»¤.
3. åœ¨æ ˆä¸Šå­˜å˜é‡çš„æ—¶å€™, è¦æ³¨æ„æŠŠæ ˆé¡¶çš„ç•™ç»™å‡½æ•°å‚æ•°çš„ä½ç½®ç©ºå‡ºæ¥, ä¸è¦å­˜å‚¨å±€éƒ¨å˜é‡, å¦åˆ™å¯èƒ½é€ æˆå‡½æ•°å‚æ•°å¯¹å±€éƒ¨å˜é‡çš„è¦†ç›–.
4. åœ¨è°ƒç”¨å®Œå‡½æ•°å, éœ€è¦æ£€æµ‹ `value->ty->tag == KOOPA_RTT_UNIT` è¿™ä¸ªæ¡ä»¶, å¦‚æœä¸ºçœŸ, åˆ™å‡½æ•°æ²¡æœ‰è¿”å›å€¼, ä¸éœ€è¦ç”Ÿæˆ `return` æŒ‡ä»¤, å¦åˆ™éœ€è¦.

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv8 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv8 /root/compiler
```

## Lv9

ç»ˆäºçŸ¥é“ä¸ºä»€ä¹ˆè¯´ç¼–è¯‘åŸç†æ¯” ICS çš„ä»»åŠ¡é‡å¤šäº†... 

å»ºè®®åœ¨æ²¡æœ‰ç»©ç‚¹å‹åŠ›çš„å¤§å››é€‰è¿™é—¨è¯¾å°±å¯ä»¥ä¸ç”¨å†™ Lv9 äº†, å› ä¸º Lv9 éå¸¸æµªè´¹æ—¶é—´å¹¶ä¸”å æ‰€æœ‰ Lab çš„ 27% çš„åˆ†æ•°, ä¹Ÿå°±æ˜¯æ€»è¯„çš„ 8 åˆ†, å¦‚æœåœ¨ç»©ç‚¹å‹åŠ›ä¸‹å®Œæˆæ‰€æœ‰ Lab ä¼šæµªè´¹å¾ˆå¤šæ—¶é—´.

å¼•æµåˆ° [Arthals çš„ç¼–è¯‘åŸç†ç›¸å…³åšå®¢](https://arthals.ink/tags/ç¼–è¯‘åŸç†/) , é‡Œé¢æœ‰æ›´å¤šå…³äºç¼–è¯‘åŸç†è¯¾ç¨‹å’Œ Lab çš„ç¬”è®°, ç›¸ä¿¡ä»–ä¼šæŠŠ Lv9 çš„ Lab è®²çš„æ›´æ¸…æ¥š.

### Compile and Test

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.koopa`:

```bash
./build/compiler -koopa debug/hello.c -o debug/hello.koopa
```

è¿è¡Œç¼–è¯‘å™¨, æŠŠ `debug/hello.c` ç¼–è¯‘ä¸º `debug/hello.S`:

```bash
./build/compiler -riscv debug/hello.c -o debug/hello.S
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `koopa`:

```bash
autotest -koopa -s lv9 /root/compiler
```

æœ¬åœ°è‡ªåŠ¨è¯„æµ‹ `riscv`:

```bash
autotest -riscv -s lv9 /root/compiler
```

## Summary

è¿™é—¨è¯¾çš„ Lab ä»»åŠ¡é‡å¾ˆå¤§, ä½†æ˜¯æ€ç»´éš¾åº¦å®é™…ä¸Šä¸å¤§, åŠ©æ•™å“¥å“¥çš„æ–‡æ¡£å†™çš„è¿˜æ˜¯æ¯”è¾ƒæ¸…æ¥šçš„, åªå»ºè®®å¤§å››åŒå­¦é€‰è¿™é—¨è¯¾, å¦åˆ™å®Œæˆ Lab çš„å‹åŠ›ä¼šå¾ˆå¤§.

è°¢è°¢å¤§å®¶!

Yutong Liang

2025-01-12
